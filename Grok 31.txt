import com.formdev.flatlaf.FlatDarkLaf;
import com.formdev.flatlaf.FlatIntelliJLaf;
import com.formdev.flatlaf.FlatLightLaf;
import com.itextpdf.text.Document;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.pdf.PdfWriter;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.jdatepicker.impl.JDatePanelImpl;
import org.jdatepicker.impl.JDatePickerImpl;
import org.jdatepicker.impl.UtilDateModel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.data.category.DefaultCategoryDataset;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.*;
import javax.swing.text.JFormattedTextField;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.io.*;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.logging.Logger;
import java.util.regex.Pattern;

/**
 * Main application class for financial management with enhanced features.
 */
public class FinancialManagementForm extends JFrame {
    private static final Logger LOGGER = Logger.getLogger(FinancialManagementForm.class.getName());
    private static final int CONTROL_PANEL_BUTTON_GAP = 5;
    private static final String STATUS_READY = "statusReady";
    private static final String STATUS_PROCESSING = "statusProcessing";
    private static final int SCHEDULER_POOL_SIZE = 1;
    private static final long SCHEDULER_INTERVAL_MINUTES = 1440; // 1 day
    private ResourceBundle messages;
    private ScheduledExecutorService scheduler;
    private JComboBox<String> themeCombo;
    private JComboBox<String> languageCombo;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private JLabel statusBar;
    private JProgressBar progressBar;
    private String currentUser = "User1"; // Placeholder until authentication is added

    public FinancialManagementForm(DatabaseService dbService, AuditService auditService) {
        this.dbService = dbService;
        this.auditService = auditService;
        SwingUtilities.invokeLater(() -> {
            setLanguage("en");
            if (!configureDatabase()) {
                dispose();
                return;
            }
            initializeUI();
            startScheduledTasks();
        });
    }

    private void setLanguage(String language) {
    try {
        messages = ResourceBundle.getBundle("messages", Locale.forLanguageTag(language));
    } catch (MissingResourceException e) {
        LOGGER.severe("Error loading language properties: " + e.getMessage());
        messages = ResourceBundle.getBundle("messages", Locale.ENGLISH);
    }
    if (isVisible()) {
        updateUIWithMessages();
        // Apply RTL for Arabic, LTR for English
        if (language.equals("ar")) {
            applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
        } else {
            applyComponentOrientation(ComponentOrientation.LEFT_TO_RIGHT);
        }
    }
}

    private void updateUIWithMessages() {
        setTitle(getMessage("title", "Financial Management"));
        for (Component c : getContentPane().getComponents()) {
            if (c instanceof JPanel && ((JPanel) c).getComponentCount() > 0) {
                updatePanelMessages((JPanel) c);
            }
        }
        JTabbedPane tabbedPane = (JTabbedPane) ((BorderLayout) getContentPane().getLayout()).getLayoutComponent(BorderLayout.CENTER);
        tabbedPane.setTitleAt(0, getMessage("dashboard", "Dashboard"));
        tabbedPane.setTitleAt(1, getMessage("invoices", "Invoices"));
        tabbedPane.setTitleAt(2, getMessage("recurringInvoices", "Recurring Invoices"));
        tabbedPane.setTitleAt(3, getMessage("inventory", "Inventory"));
        tabbedPane.setTitleAt(4, getMessage("attachments", "Attachments"));
        tabbedPane.setTitleAt(5, getMessage("customersSuppliers", "Customers & Suppliers"));
        tabbedPane.setTitleAt(6, getMessage("expenses", "Expenses"));
        tabbedPane.setTitleAt(7, getMessage("reports", "Reports"));
        tabbedPane.setTitleAt(8, getMessage("adjustments", "Adjustments"));
        tabbedPane.setTitleAt(9, getMessage("auditTrail", "Audit Trail"));
        statusBar.setText(getMessage(STATUS_READY, "Ready"));
    }

    private void updatePanelMessages(JPanel panel) {
        for (Component comp : panel.getComponents()) {
            if (comp instanceof JButton) {
                JButton btn = (JButton) comp;
                String text = btn.getText();
                if (text != null && !text.isEmpty()) {
                    btn.setText(getMessage(text.toLowerCase().replace(" ", ""), text));
                }
            } else if (comp instanceof JCheckBox) {
                JCheckBox cb = (JCheckBox) comp;
                cb.setText(getMessage("darkTheme", "Dark Theme"));
            } else if (comp instanceof JPanel) {
                updatePanelMessages((JPanel) comp);
            }
        }
    }

    private boolean configureDatabase() {
        DatabaseConfigDialog configDialog = new DatabaseConfigDialog(this, messages);
        configDialog.setVisible(true);
        return configDialog.isConfirmed();
    }

    private void initializeUI() {
        try {
            FlatLightLaf.setup();
        } catch (Exception e) {
            LOGGER.severe("Failed to initialize FlatLaf: " + e.getMessage());
            ErrorHandler.handleException(e, "UI theme initialization failed", this);
        }
        setTitle(getMessage("title", "Financial Management"));
        setSize(1200, 900);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, CONTROL_PANEL_BUTTON_GAP, CONTROL_PANEL_BUTTON_GAP));
        themeCombo = new JComboBox<>(new String[]{"Light", "Dark", "IntelliJ"});
        themeCombo.addActionListener(e -> changeTheme());
        themeCombo.setToolTipText("Select UI theme");
        controlPanel.add(themeCombo);

        languageCombo = new JComboBox<>(new String[]{"English", "Arabic"});
	languageCombo.addActionListener(e -> setLanguage(languageCombo.getSelectedItem().equals("English") ? "en" : "ar"));
        languageCombo.setToolTipText("Select language");
        controlPanel.add(languageCombo);

        JButton newInvoiceButton = createButton(getMessage("newInvoice", "New Invoice"), KeyEvent.VK_N, this::openNewInvoiceWindow);
        newInvoiceButton.setToolTipText("Create a new invoice (Ctrl+N)");
        controlPanel.add(newInvoiceButton);

        JButton markPaymentButton = new JButton(getMessage("markPaymentReceived", "Mark Payment Received"));
        markPaymentButton.addActionListener(e -> markPaymentReceived());
        markPaymentButton.setToolTipText("Record a general payment from a customer");
        controlPanel.add(markPaymentButton);

        JButton databaseMenuButton = new JButton(getMessage("database", "Database"));
        JPopupMenu databaseMenu = new JPopupMenu();
        JMenuItem changeDbItem = new JMenuItem(getMessage("changeDatabase", "Change Database"));
        changeDbItem.addActionListener(e -> changeDatabase());
        databaseMenu.add(changeDbItem);
        JMenuItem newDbItem = new JMenuItem(getMessage("newDatabase", "New Database"));
        newDbItem.addActionListener(e -> createNewDatabase());
        databaseMenu.add(newDbItem);
        databaseMenuButton.addActionListener(e -> databaseMenu.show(databaseMenuButton, 0, databaseMenuButton.getHeight()));
        databaseMenuButton.setToolTipText("Database management options");
        controlPanel.add(databaseMenuButton);

        JTabbedPane tabbedPane = new JTabbedPane();
        tabbedPane.addTab(getMessage("dashboard", "Dashboard"), new DashboardPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("invoices", "Invoices"), new InvoicePanel(messages, dbService, auditService, false));
        tabbedPane.addTab(getMessage("recurringInvoices", "Recurring Invoices"), new RecurringInvoicePanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("inventory", "Inventory"), new InventoryPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("attachments", "Attachments"), new AttachmentPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("customersSuppliers", "Customers & Suppliers"), new ContactsPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("expenses", "Expenses"), new ExpensesPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("reports", "Reports"), new ReportPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("adjustments", "Adjustments"), new AdjustmentsPanel(messages, dbService, auditService));
        tabbedPane.addTab(getMessage("auditTrail", "Audit Trail"), new AuditTrailPanel(messages, dbService, auditService));
        tabbedPane.getAccessibleContext().setAccessibleName("Main Navigation Tabs");

        statusBar = new JLabel(getMessage(STATUS_READY, "Ready"));
        statusBar.getAccessibleContext().setAccessibleName("Status Bar");
        progressBar = new JProgressBar();
        progressBar.setVisible(false);
        progressBar.getAccessibleContext().setAccessibleName("Progress Indicator");
        JPanel statusPanel = new JPanel(new BorderLayout());
        statusPanel.add(statusBar, BorderLayout.CENTER);
        statusPanel.add(progressBar, BorderLayout.EAST);

        add(controlPanel, BorderLayout.NORTH);
        add(tabbedPane, BorderLayout.CENTER);
        add(statusPanel, BorderLayout.SOUTH);

        setVisible(true);
    }

    private String getMessage(String key, String defaultValue) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            LOGGER.warning("Missing resource key: " + key + ", using default: " + defaultValue);
            return defaultValue;
        }
    }

    private JButton createButton(String text, int mnemonic, Runnable action) {
        JButton button = new JButton(text);
        button.setMnemonic(mnemonic);
        button.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(
            KeyStroke.getKeyStroke(mnemonic, InputEvent.CTRL_DOWN_MASK), text);
        button.getActionMap().put(text, new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                action.run();
            }
        });
        button.getAccessibleContext().setAccessibleName(text + " Button");
        return button;
    }

    private void changeTheme() {
        SwingUtilities.invokeLater(() -> {
            try {
                String selectedTheme = (String) themeCombo.getSelectedItem();
                switch (selectedTheme) {
                    case "Dark": FlatDarkLaf.setup(); break;
                    case "IntelliJ": FlatIntelliJLaf.setup(); break;
                    default: FlatLightLaf.setup(); break;
                }
                SwingUtilities.updateComponentTreeUI(this);
            } catch (Exception e) {
                ErrorHandler.handleException(e, "Failed to change theme", this);
            }
        });
    }

    private void openNewInvoiceWindow() {
        SwingUtilities.invokeLater(() -> {
            NewInvoiceWindow newInvoiceWindow = new NewInvoiceWindow(messages, dbService, auditService);
            newInvoiceWindow.setVisible(true);
        });
    }

    private void markPaymentReceived() {
        CompletableFuture.runAsync(() -> {
            try {
                String customerName = JOptionPane.showInputDialog(this, getMessage("enterCustomerName", "Enter Customer Name"));
                ErrorHandler.validateRequiredField(customerName, "Customer Name");
                ErrorHandler.validateString(customerName, "Customer Name");

                JTextField amountField = new JTextField(10);
                JComboBox<String> currencyDropdown = new JComboBox<>(new String[]{"USD", "IQD", "RMB"});
                JTextField exchangeRateField = new JTextField("1.0", 10);
                JPanel paymentPanel = new JPanel(new GridLayout(3, 2));
                paymentPanel.add(new JLabel("Payment Amount:"));
                paymentPanel.add(amountField);
                paymentPanel.add(new JLabel("Currency:"));
                paymentPanel.add(currencyDropdown);
                paymentPanel.add(new JLabel("Exchange Rate (to USD):"));
                paymentPanel.add(exchangeRateField);

                int result = JOptionPane.showConfirmDialog(this, paymentPanel, "Enter General Payment", JOptionPane.OK_CANCEL_OPTION);
                if (result != JOptionPane.OK_OPTION) return;

                double amount = ErrorHandler.validatePositiveDouble(amountField.getText(), "Payment Amount");
                String currency = (String) currencyDropdown.getSelectedItem();
                double exchangeRate = ErrorHandler.validatePositiveDouble(exchangeRateField.getText(), "Exchange Rate");

                showProgress(true);
                dbService.markPaymentReceived(customerName, amount, currency, exchangeRate, null);
                auditService.logAction(currentUser, "payments", null, "General payment received: " + amount + " " + currency + " from " + customerName, null, null);
                SwingUtilities.invokeLater(() -> {
                    JOptionPane.showMessageDialog(this, getMessage("paymentReceived", "Payment Received: ") + amount + " " + currency + " from " + customerName);
                    int printOption = JOptionPane.showConfirmDialog(this, "Would you like to print the payment receipt?", "Print Receipt", JOptionPane.YES_NO_OPTION);
                    if (printOption == JOptionPane.YES_OPTION) {
                        printGeneralPaymentReceipt(customerName, amount, currency, exchangeRate);
                    }
                });
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            } finally {
                showProgress(false);
            }
        }, Executors.newCachedThreadPool()).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to mark payment", this);
            showProgress(false);
            return null;
        });
    }

    private void printGeneralPaymentReceipt(String customerName, double amount, String currency, double exchangeRate) {
        try {
            JTextArea receiptArea = new JTextArea(10, 40);
            receiptArea.setEditable(false);
            receiptArea.append("Payment Receipt\n");
            receiptArea.append("------------------------\n");
            receiptArea.append("Customer: " + customerName + "\n");
            receiptArea.append("Invoice Reference: General Payment\n");
            receiptArea.append("Amount: " + String.format("%.2f", amount) + " " + currency + "\n");
            receiptArea.append("Exchange Rate (to USD): " + String.format("%.2f", exchangeRate) + "\n");
            receiptArea.append("Amount in USD: " + String.format("%.2f", currency.equals("USD") ? amount : amount / exchangeRate) + " USD\n");
            receiptArea.append("Date: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + "\n");
            receiptArea.append("------------------------\n");

            boolean complete = receiptArea.print();
            if (complete) {
                auditService.logAction(currentUser, "payments", null, "Printed general payment receipt for customer: " + customerName, null, null);
                JOptionPane.showMessageDialog(this, "Payment receipt printed successfully.");
            } else {
                JOptionPane.showMessageDialog(this, "Payment receipt printing cancelled.");
            }

            int pdfOption = JOptionPane.showConfirmDialog(this, "Would you like to save the receipt as PDF?", "Save as PDF", JOptionPane.YES_NO_OPTION);
            if (pdfOption == JOptionPane.YES_OPTION) {
                Document document = new Document();
                PdfWriter.getInstance(document, new FileOutputStream("Payment_Receipt_General_" + System.currentTimeMillis() + ".pdf"));
                document.open();
                document.add(new Paragraph(receiptArea.getText()));
                document.close();
                auditService.logAction(currentUser, "payments", null, "Exported general payment receipt to PDF for customer: " + customerName, null, null);
                JOptionPane.showMessageDialog(this, "Payment receipt saved as PDF.");
            }
        } catch (Exception e) {
            ErrorHandler.handleException(e, "Failed to print or save payment receipt", this);
        }
    }

    private void changeDatabase() {
        DatabaseConfigDialog configDialog = new DatabaseConfigDialog(this, messages);
        configDialog.setVisible(true);
        if (configDialog.isConfirmed()) {
            SwingUtilities.invokeLater(() -> {
                JOptionPane.showMessageDialog(this, getMessage("dbConfigUpdated", "Database configuration updated"));
                dispose();
                new FinancialManagementForm(dbService, auditService);
            });
        }
    }

    private void createNewDatabase() {
        String dbName = JOptionPane.showInputDialog(this, getMessage("enterNewDbName", "Enter New Database Name"));
        if (ErrorHandler.validateStringSafe(dbName, "Database Name")) {
            CompletableFuture.runAsync(() -> {
                try {
                    showProgress(true);
                    dbService.createNewDatabase(dbName);
                    auditService.logAction(currentUser, "databases", null, "Created new database: " + dbName, null, null);
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, getMessage("dbCreated", "Database created: ") + dbName);
                        changeDatabase();
                    });
                } catch (DatabaseException e) {
                    ErrorHandler.handleException(e, getMessage("errorCreatingDb", "Error creating database: ") + dbName, this);
                } finally {
                    showProgress(false);
                }
            }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
                ErrorHandler.handleException(throwable, "Failed to create database", this);
                showProgress(false);
                return null;
            });
        }
    }

    private void startScheduledTasks() {
        scheduler = Executors.newScheduledThreadPool(SCHEDULER_POOL_SIZE);
        scheduler.scheduleAtFixedRate(() -> {
            try {
                showProgress(true);
                List<String> overduePayments = dbService.getOverduePayments(1, 100);
                if (!overduePayments.isEmpty()) {
                    StringBuilder message = new StringBuilder(getMessage("overduePayments", "Overdue Payments") + "\n");
                    overduePayments.forEach(payment -> message.append(payment).append("\n"));
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, message.toString(), getMessage("overduePaymentsTitle", "Overdue Payments"), JOptionPane.WARNING_MESSAGE));
                }
                dbService.processRecurringInvoices();
            } catch (DatabaseException e) {
                LOGGER.severe("Error checking overdue payments or processing recurring invoices: " + e.getMessage());
            } finally {
                showProgress(false);
            }
        }, 0, SCHEDULER_INTERVAL_MINUTES, TimeUnit.MINUTES);
    }

    private void showProgress(boolean show) {
        SwingUtilities.invokeLater(() -> {
            progressBar.setVisible(show);
            statusBar.setText(show ? getMessage(STATUS_PROCESSING, "Processing...") : getMessage(STATUS_READY, "Ready"));
        });
    }

    @Override
    public void dispose() {
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdownNow();
        }
        dbService.close();
        super.dispose();
    }

    public static void main(String[] args) {
        DatabaseService dbService = new DatabaseService();
        try {
            dbService.setConnectionDetails("jdbc:mysql://localhost:3306/AccountingSoftware", "alrand", "password");
        } catch (DatabaseException e) {
            JOptionPane.showMessageDialog(null, "Failed to initialize database: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        AuditService auditService = new AuditService(dbService);
        SwingUtilities.invokeLater(() -> new FinancialManagementForm(dbService, auditService));
    }
}

/**
 * Dialog for configuring database connection details.
 */
class DatabaseConfigDialog extends JDialog {
    private static final String DEFAULT_DB_URL = "jdbc:mysql://localhost:3306/AccountingSoftware";
    private static final String DEFAULT_USERNAME = "alrand";
    private JTextField urlField, usernameField;
    private JPasswordField passwordField;
    private boolean confirmed = false;
    private ResourceBundle messages;

    public DatabaseConfigDialog(Frame owner, ResourceBundle messages) {
        super(owner, messages.getString("dbConfigTitle"), true);
        this.messages = messages;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);

        gbc.gridx = 0; gbc.gridy = 0;
        JLabel urlLabel = new JLabel(messages.getString("dbUrl"));
        urlLabel.getAccessibleContext().setAccessibleName("Database URL Label");
        add(urlLabel, gbc);
        gbc.gridx = 1;
        urlField = new JTextField(DEFAULT_DB_URL, 20);
        urlField.setToolTipText("Enter the database URL (e.g., jdbc:mysql://localhost:3306/dbname)");
        urlField.getAccessibleContext().setAccessibleName("Database URL Field");
        add(urlField, gbc);

        gbc.gridx = 0; gbc.gridy = 1;
        JLabel usernameLabel = new JLabel(messages.getString("dbUsername"));
        usernameLabel.getAccessibleContext().setAccessibleName("Username Label");
        add(usernameLabel, gbc);
        gbc.gridx = 1;
        usernameField = new JTextField(DEFAULT_USERNAME, 20);
        usernameField.setToolTipText("Enter the database username");
        usernameField.getAccessibleContext().setAccessibleName("Username Field");
        add(usernameField, gbc);

        gbc.gridx = 0; gbc.gridy = 2;
        JLabel passwordLabel = new JLabel(messages.getString("dbPassword"));
        passwordLabel.getAccessibleContext().setAccessibleName("Password Label");
        add(passwordLabel, gbc);
        gbc.gridx = 1;
        passwordField = new JPasswordField(20);
        passwordField.setToolTipText("Enter the database password");
        passwordField.getAccessibleContext().setAccessibleName("Password Field");
        add(passwordField, gbc);

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 2;
        JButton connectButton = new JButton(messages.getString("connect"));
        connectButton.addActionListener(e -> connect());
        connectButton.setToolTipText("Connect to the database");
        connectButton.getAccessibleContext().setAccessibleName("Connect Button");
        add(connectButton, gbc);

        pack();
        setLocationRelativeTo(null);
    }

    private void connect() {
        String url = urlField.getText();
        String username = usernameField.getText();
        String password = new String(passwordField.getPassword());
        try {
            ErrorHandler.validateRequiredField(url, "Database URL");
            ErrorHandler.validateRequiredField(username, "Username");
            ErrorHandler.validateRequiredField(password, "Password");
            DatabaseService.setConnectionDetails(url, username, password);
            confirmed = true;
            dispose();
        } catch (ValidationException | DatabaseException e) {
            ErrorHandler.handleException(e, e.getMessage(), this);
        }
    }

    public boolean isConfirmed() {
        return confirmed;
    }
}

/**
 * Window for creating new invoices.
 */
class NewInvoiceWindow extends JFrame {
    private InvoicePanel invoicePanel;

    public NewInvoiceWindow(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        SwingUtilities.invokeLater(() -> {
            setTitle(messages.getString("newInvoice"));
            setSize(800, 600);
            setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
            setLayout(new BorderLayout());

            invoicePanel = new InvoicePanel(messages, dbService, auditService, true);
            add(invoicePanel, BorderLayout.CENTER);

            pack();
            setLocationRelativeTo(null);
            setVisible(true);
        });
    }
}

/**
 * Virtual Table Model for DashboardPanel with caching
 */
class VirtualDashboardTableModel extends AbstractTableModel {
    private final List<Object[]> allRows = new ArrayList<>();
    private int totalRowCount = 0;

    public void setAllRows(List<Object[]> rows) {
        allRows.clear();
        allRows.addAll(rows);
        totalRowCount = allRows.size();
        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 2; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        return allRows.get(rowIndex)[columnIndex];
    }

    @Override
    public String getColumnName(int column) {
        return column == 0 ? "Metric" : "Value";
    }
}

/**
 * Panel for displaying key performance indicators (KPIs).
 */
class DashboardPanel extends JPanel {
    private JTable dashboardTable;
    private VirtualDashboardTableModel dashboardTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private JPanel chartPanel;

    public DashboardPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
        refreshDashboard();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        dashboardTableModel = new VirtualDashboardTableModel();
        dashboardTable = new JTable(dashboardTableModel);
        dashboardTable.setToolTipText(getMessage("keyPerformanceIndicators"));
        dashboardTable.getAccessibleContext().setAccessibleName("Dashboard Table");
        JScrollPane scrollPane = new JScrollPane(dashboardTable);
        chartPanel = new JPanel();
        chartPanel.setToolTipText("Chart of key metrics");
        chartPanel.getAccessibleContext().setAccessibleName("Chart Panel");
        add(new JSplitPane(JSplitPane.VERTICAL_SPLIT, scrollPane, chartPanel), BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> refreshDashboard());
        refreshButton.setToolTipText("Refresh dashboard data");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Button");
        buttonPanel.add(refreshButton);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void refreshDashboard() {
        CompletableFuture.runAsync(() -> {
            try {
                List<Object[]> kpis = new ArrayList<>();
                double totalSales = dbService.getTotalSales();
                double overdueAmount = dbService.getOverdueAmount();
                double cashBalance = dbService.getCashBalance();
                kpis.add(new Object[]{getMessage("totalSales", "Total Sales") + " (USD)", String.format("%.2f", totalSales)});
                kpis.add(new Object[]{getMessage("overduePayments", "Overdue Payments") + " (USD)", String.format("%.2f", overdueAmount)});
                kpis.add(new Object[]{getMessage("cashBalance", "Cash Balance") + " (USD)", String.format("%.2f", cashBalance)});

                SwingUtilities.invokeLater(() -> {
                    dashboardTableModel.setAllRows(kpis);
                    DefaultCategoryDataset dataset = new DefaultCategoryDataset();
                    dataset.addValue(totalSales, "Metrics", "Total Sales");
                    dataset.addValue(overdueAmount, "Metrics", "Overdue Payments");
                    dataset.addValue(cashBalance, "Metrics", "Cash Balance");
                    JFreeChart barChart = ChartFactory.createBarChart(
                        getMessage("dashboard", "Dashboard"),
                        "Metric",
                        "Value (USD)",
                        dataset
                    );
                    chartPanel.removeAll();
                    chartPanel.add(new ChartPanel(barChart));
                    chartPanel.revalidate();
                    chartPanel.repaint();
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingDashboard", "Error loading dashboard data"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to refresh dashboard", this);
            return null;
        });
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }
}

/**
 * Virtual Table Model for InvoicePanel with caching
 */
class VirtualInvoiceTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final List<InvoiceLineItem> visibleRows = new ArrayList<>();
    private List<InvoiceLineItem> allRows = new ArrayList<>();
    private final Map<String, List<InvoiceLineItem>> pageCache = new LinkedHashMap<String, List<InvoiceLineItem>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<String, List<InvoiceLineItem>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualInvoiceTableModel(DatabaseService dbService) {
        this.dbService = dbService;
    }

    public void setAllRows(List<InvoiceLineItem> rows) {
        allRows = new ArrayList<>(rows);
        totalRowCount = allRows.size();
        pageCache.clear();
        fireTableDataChanged();
    }

    public void addRow(InvoiceLineItem item) {
        allRows.add(item);
        totalRowCount = allRows.size();
        pageCache.clear();
        updateVisibleRows(firstVisibleRow, visibleRowCount);
    }

    public void removeRow(int index) {
        if (index >= 0 && index < allRows.size()) {
            allRows.remove(index);
            totalRowCount = allRows.size();
            pageCache.clear();
            updateVisibleRows(firstVisibleRow, visibleRowCount);
        }
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();
        visibleRows.addAll(allRows.subList(firstVisibleRow, Math.min(firstVisibleRow + visibleRowCount, totalRowCount)));
        fireTableDataChanged();
    }

    @Override
    public int getRowCount() {
        return totalRowCount;
    }

    @Override
    public int getColumnCount() {
        return 8;
    }

    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) {
            return columnIndex == 7 ? "+" : "";
        }
        InvoiceLineItem item = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return item.getDescription();
            case 1: return dbService.getWarehouseCache().getOrDefault(item.getWarehouseId(), "Unknown");
            case 2: return item.getQuantity();
            case 3: return item.getUnit();
            case 4: return item.getUnitPrice();
            case 5: return item.getTotalPrice();
            case 6: return item.getCurrency();
            case 7: return "+";
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Description";
            case 1: return "Warehouse";
            case 2: return "Quantity";
            case 3: return "Unit";
            case 4: return "Unit Price";
            case 5: return "Total Price";
            case 6: return "Currency";
            case 7: return "";
            default: return "";
        }
    }

    @Override
    public boolean isCellEditable(int row, int column) {
        return column == 1 || column == 6 || column == 7;
    }
}

/**
 * Panel for managing invoices with virtual scrolling and caching.
 */
class InvoicePanel extends JPanel {
    private static final String INVOICE_PREFIX = "INV";
    private static final int PAGE_SIZE = 50;
    private JTextField invoiceIdField, lastDebitField, paymentTermsField, exchangeRateField;
    private JTextArea notesArea;
    private JComboBox<String> invoiceTypeDropdown, customerDropdown;
    private JTable lineItemsTable;
    private VirtualInvoiceTableModel lineItemsTableModel;
    private JDatePickerImpl datePicker;
    private JLabel usdTotalLabel, localTotalLabel, customerPageLabel;
    private JCheckBox recurringCheckBox;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private final boolean isNewInvoiceMode;
    private int customerPage = 1;
    private int totalCustomerPages = 1;
    private JButton prevCustomerButton, nextCustomerButton;
    private JTextField customerSearch;
    private final Stack<Command> undoStack = new Stack<>();
    private final Stack<Command> redoStack = new Stack<>();
    private JScrollPane lineItemsScrollPane;
    private String currentUser = "User1";

    public InvoicePanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService, boolean isNewInvoiceMode) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        this.isNewInvoiceMode = isNewInvoiceMode;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.fill = GridBagConstraints.HORIZONTAL;

        gbc.gridx = 0; gbc.gridy = 0;
        JLabel typeLabel = new JLabel(getMessage("invoiceType", "Invoice Type"));
        typeLabel.getAccessibleContext().setAccessibleName("Invoice Type Label");
        add(typeLabel, gbc);
        gbc.gridx = 1;
        invoiceTypeDropdown = new JComboBox<>(new String[]{"Sale", "Purchase", "Import", "Sale Return", "Purchase Return"});
        invoiceTypeDropdown.addActionListener(e -> adjustUIForInvoiceType());
        invoiceTypeDropdown.setToolTipText("Select the type of invoice");
        invoiceTypeDropdown.getAccessibleContext().setAccessibleName("Invoice Type Selector");
        add(invoiceTypeDropdown, gbc);

        gbc.gridx = 0; gbc.gridy = 1;
        JLabel idLabel = new JLabel(getMessage("invoiceId", "Invoice ID"));
        idLabel.getAccessibleContext().setAccessibleName("Invoice ID Label");
        add(idLabel, gbc);
        gbc.gridx = 1;
        if (!isNewInvoiceMode) {
            invoiceIdField = new JTextField(20);
            invoiceIdField.setToolTipText("Enter the invoice ID to view or edit");
        } else {
            try {
                invoiceIdField = new JTextField(dbService.generateInvoiceId(INVOICE_PREFIX), 20);
                invoiceIdField.setEditable(false);
                invoiceIdField.setToolTipText("Generated invoice ID");
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorGeneratingInvoiceId", "Error generating invoice ID"), this);
                invoiceIdField = new JTextField(20);
            }
        }
        invoiceIdField.getAccessibleContext().setAccessibleName("Invoice ID Field");
        add(invoiceIdField, gbc);

        gbc.gridx = 0; gbc.gridy = 2;
        JLabel searchLabel = new JLabel(getMessage("customerSearch", "Customer Search"));
        searchLabel.getAccessibleContext().setAccessibleName("Customer Search Label");
        add(searchLabel, gbc);
        gbc.gridx = 1;
        customerSearch = new JTextField(20);
        customerSearch.setToolTipText("Type to filter customers/suppliers");
        customerSearch.getAccessibleContext().setAccessibleName("Customer Search Field");
        add(customerSearch, gbc);
        customerSearch.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) { filterCustomers(); }
            @Override
            public void removeUpdate(DocumentEvent e) { filterCustomers(); }
            @Override
            public void changedUpdate(DocumentEvent e) { filterCustomers(); }
        });

        gbc.gridx = 0; gbc.gridy = 3;
        JLabel customerLabel = new JLabel(getMessage("customerSupplier", "Customer/Supplier"));
        customerLabel.getAccessibleContext().setAccessibleName("Customer Label");
        add(customerLabel, gbc);
        gbc.gridx = 1;
        customerDropdown = new JComboBox<>();
        customerDropdown.setToolTipText("Select a customer or supplier");
        customerDropdown.getAccessibleContext().setAccessibleName("Customer Selector");
        loadCustomers(customerPage);
        customerDropdown.addActionListener(e -> updateDebitField());
        add(customerDropdown, gbc);

        gbc.gridx = 2;
        prevCustomerButton = new JButton(getMessage("prev", "Previous"));
        prevCustomerButton.addActionListener(e -> {
            if (customerPage > 1) {
                customerPage--;
                loadCustomers(customerPage);
            }
        });
        prevCustomerButton.setToolTipText("Previous page of customers/suppliers");
        prevCustomerButton.getAccessibleContext().setAccessibleName("Previous Customer Page Button");
        add(prevCustomerButton, gbc);

        gbc.gridx = 3;
        customerPageLabel = new JLabel("Page " + customerPage + " of " + totalCustomerPages);
        customerPageLabel.setToolTipText("Current customer/supplier page");
        customerPageLabel.getAccessibleContext().setAccessibleName("Customer Page Indicator");
        add(customerPageLabel, gbc);

        gbc.gridx = 4;
        nextCustomerButton = new JButton(getMessage("next", "Next"));
        nextCustomerButton.addActionListener(e -> {
            if (customerPage < totalCustomerPages) {
                customerPage++;
                loadCustomers(customerPage);
            }
        });
        nextCustomerButton.setToolTipText("Next page of customers/suppliers");
        nextCustomerButton.getAccessibleContext().setAccessibleName("Next Customer Page Button");
        add(nextCustomerButton, gbc);

        gbc.gridx = 0; gbc.gridy = 4;
        JLabel dateLabel = new JLabel(getMessage("date", "Date"));
        dateLabel.getAccessibleContext().setAccessibleName("Date Label");
        add(dateLabel, gbc);
        gbc.gridx = 1;
        UtilDateModel model = new UtilDateModel();
        Properties p = new Properties();
        p.put("text.today", getMessage("today", "Today"));
        JDatePanelImpl datePanel = new JDatePanelImpl(model, p);
        datePicker = new JDatePickerImpl(datePanel, new DateLabelFormatter());
        datePicker.setToolTipText("Select the invoice date (yyyy-MM-dd)");
        datePicker.getAccessibleContext().setAccessibleName("Date Picker");
        add(datePicker, gbc);

        gbc.gridx = 0; gbc.gridy = 5;
        JLabel exchangeLabel = new JLabel(getMessage("exchangeRate", "Exchange Rate") + " (to USD)");
        exchangeLabel.getAccessibleContext().setAccessibleName("Exchange Rate Label");
        add(exchangeLabel, gbc);
        gbc.gridx = 1;
        exchangeRateField = new JTextField("1.0", 10);
        exchangeRateField.setToolTipText("Enter the exchange rate to USD (e.g., 1.0 for USD, 7.25 for RMB)");
        exchangeRateField.getAccessibleContext().setAccessibleName("Exchange Rate Field");
        add(exchangeRateField, gbc);

        gbc.gridx = 0; gbc.gridy = 6;
        JLabel termsLabel = new JLabel(getMessage("paymentTerms", "Payment Terms"));
        termsLabel.getAccessibleContext().setAccessibleName("Payment Terms Label");
        add(termsLabel, gbc);
        gbc.gridx = 1;
        paymentTermsField = new JTextField("e.g., 30 days", 20);
        paymentTermsField.setToolTipText("Enter payment terms (e.g., '30 days')");
        paymentTermsField.getAccessibleContext().setAccessibleName("Payment Terms Field");
        add(paymentTermsField, gbc);

        gbc.gridx = 0; gbc.gridy = 7;
        JLabel debitLabel = new JLabel(getMessage("lastDebit", "Last Debit"));
        debitLabel.getAccessibleContext().setAccessibleName("Last Debit Label");
        add(debitLabel, gbc);
        gbc.gridx = 1;
        lastDebitField = new JTextField(20);
        lastDebitField.setEditable(false);
        lastDebitField.setToolTipText("Customer's current debit amount (USD)");
        lastDebitField.getAccessibleContext().setAccessibleName("Last Debit Field");
        add(lastDebitField, gbc);

        gbc.gridx = 0; gbc.gridy = 8;
        JLabel usdTotalTitleLabel = new JLabel(getMessage("totalAmount", "Total Amount") + " (USD)");
        usdTotalTitleLabel.getAccessibleContext().setAccessibleName("Total Amount USD Label");
        add(usdTotalTitleLabel, gbc);
        gbc.gridx = 1;
        usdTotalLabel = new JLabel("0.00");
        usdTotalLabel.setToolTipText("Total amount in USD");
        usdTotalLabel.getAccessibleContext().setAccessibleName("Total Amount USD Value");
        add(usdTotalLabel, gbc);

        gbc.gridx = 0; gbc.gridy = 9;
        JLabel localTotalTitleLabel = new JLabel(getMessage("totalAmount", "Total Amount") + " (Local)");
        localTotalTitleLabel.getAccessibleContext().setAccessibleName("Total Amount Local Label");
        add(localTotalTitleLabel, gbc);
        gbc.gridx = 1;
        localTotalLabel = new JLabel("0.00");
        localTotalLabel.setToolTipText("Total amount in local currency");
        localTotalLabel.getAccessibleContext().setAccessibleName("Total Amount Local Value");
        add(localTotalLabel, gbc);

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 5;
        lineItemsTableModel = new VirtualInvoiceTableModel(dbService);
        lineItemsTable = new JTable(lineItemsTableModel) {
            @Override
            public TableCellRenderer getCellRenderer(int row, int column) {
                if (column == 7) return new ButtonRenderer();
                return super.getCellRenderer(row, column);
            }

            @Override
            public TableCellEditor getCellEditor(int row, int column) {
                if (column == 7) return new ButtonEditor(new JCheckBox(), this::addLineItem);
                return super.getCellEditor(row, column);
            }
        };
        lineItemsTable.getColumnModel().getColumn(1).setCellEditor(new DefaultCellEditor(new JComboBox<>()));
        lineItemsTable.getColumnModel().getColumn(6).setCellEditor(new DefaultCellEditor(new JComboBox<>(new String[]{"USD", "IQD", "RMB"})));
        lineItemsTable.getColumnModel().getColumn(7).setPreferredWidth(30);
        loadWarehouseOptions();
        lineItemsTable.setToolTipText("Invoice line items; click '+' to add a new item");
        lineItemsTable.getAccessibleContext().setAccessibleName("Line Items Table");
        lineItemsScrollPane = new JScrollPane(lineItemsTable);
        lineItemsScrollPane.getViewport().addChangeListener(e -> updateVisibleLineItems());
        add(lineItemsScrollPane, gbc);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 5;
        JLabel notesLabel = new JLabel(getMessage("notes", "Notes"));
        notesLabel.getAccessibleContext().setAccessibleName("Notes Label");
        add(notesLabel, gbc);
        gbc.gridy = 12;
        notesArea = new JTextArea(3, 20);
        notesArea.setToolTipText("Enter additional notes for the invoice");
        notesArea.getAccessibleContext().setAccessibleName("Notes Area");
        add(new JScrollPane(notesArea), gbc);

        gbc.gridwidth = 1;
        gbc.gridx = 0; gbc.gridy = 13;
        recurringCheckBox = new JCheckBox(getMessage("recurring", "Recurring"));
        recurringCheckBox.setToolTipText("Mark as a recurring invoice");
        recurringCheckBox.getAccessibleContext().setAccessibleName("Recurring CheckBox");
        add(recurringCheckBox, gbc);

        gbc.gridx = 1;
        JButton addLineItemButton = new JButton(getMessage("addLineItem", "Add Line Item"));
        addLineItemButton.addActionListener(e -> addLineItem());
        addLineItemButton.setToolTipText("Add a new line item to the invoice");
        addLineItemButton.getAccessibleContext().setAccessibleName("Add Line Item Button");
        add(addLineItemButton, gbc);

        gbc.gridx = 2;
        JButton saveButton = new JButton(getMessage("saveInvoice", "Save Invoice"));
        saveButton.addActionListener(e -> saveInvoice());
        saveButton.setToolTipText("Save the invoice");
        saveButton.getAccessibleContext().setAccessibleName("Save Invoice Button");
        add(saveButton, gbc);

        gbc.gridx = 3;
        JButton undoButton = new JButton(getMessage("undo", "Undo"));
        undoButton.addActionListener(e -> undo());
        undoButton.setToolTipText("Undo the last action");
        undoButton.getAccessibleContext().setAccessibleName("Undo Button");
        add(undoButton, gbc);

        gbc.gridx = 4;
        JButton redoButton = new JButton(getMessage("redo", "Redo"));
        redoButton.addActionListener(e -> redo());
        redoButton.setToolTipText("Redo the last undone action");
        redoButton.getAccessibleContext().setAccessibleName("Redo Button");
        add(redoButton, gbc);

        if (!isNewInvoiceMode) {
            gbc.gridx = 0; gbc.gridy = 14;
            JButton viewButton = new JButton(getMessage("viewInvoice", "View Invoice"));
            viewButton.addActionListener(e -> viewInvoice());
            viewButton.setToolTipText("View invoice details");
            viewButton.getAccessibleContext().setAccessibleName("View Invoice Button");
            add(viewButton, gbc);

            gbc.gridx = 1;
            JButton editButton = new JButton(getMessage("editInvoice", "Edit Invoice"));
            editButton.addActionListener(e -> editInvoice());
            editButton.setToolTipText("Edit the selected invoice");
            editButton.getAccessibleContext().setAccessibleName("Edit Invoice Button");
            add(editButton, gbc);

            gbc.gridx = 2;
            JButton historyButton = new JButton(getMessage("viewHistory", "View History"));
            historyButton.addActionListener(e -> viewHistory());
            historyButton.setToolTipText("View invoice change history");
            historyButton.getAccessibleContext().setAccessibleName("View History Button");
            add(historyButton, gbc);

            gbc.gridx = 3;
            JButton paymentButton = new JButton("Payments");
            paymentButton.addActionListener(e -> recordInvoicePayment());
            paymentButton.setToolTipText("Record a payment for this invoice");
            paymentButton.getAccessibleContext().setAccessibleName("Payments Button");
            add(paymentButton, gbc);
        } else {
            gbc.gridx = 0; gbc.gridy = 14;
            JButton printButton = new JButton(getMessage("print", "Print"));
            printButton.addActionListener(e -> printInvoice());
            printButton.setToolTipText("Print the invoice");
            printButton.getAccessibleContext().setAccessibleName("Print Button");
            add(printButton, gbc);

            gbc.gridx = 1;
            JButton exportButton = new JButton(getMessage("exportPdf", "Export to PDF"));
            exportButton.addActionListener(e -> exportToPdf());
            exportButton.setToolTipText("Export invoice to PDF");
            exportButton.getAccessibleContext().setAccessibleName("Export PDF Button");
            add(exportButton, gbc);
        }

        adjustUIForInvoiceType();
        updateDebitField();
    }

    private void updateVisibleLineItems() {
        JViewport viewport = lineItemsScrollPane.getViewport();
        int rowHeight = lineItemsTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        lineItemsTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }

    private void adjustUIForInvoiceType() {
        String type = (String) invoiceTypeDropdown.getSelectedItem();
        boolean isPurchaseOrImport = type.equals("Purchase") || type.equals("Import");
        customerDropdown.setEnabled(!isPurchaseOrImport);
        lastDebitField.setEnabled(!isPurchaseOrImport);
        prevCustomerButton.setEnabled(!isPurchaseOrImport);
        nextCustomerButton.setEnabled(!isPurchaseOrImport);
        customerSearch.setEnabled(!isPurchaseOrImport);
    }

    private void loadCustomers(int page) {
        CompletableFuture.runAsync(() -> {
            try {
                String type = (String) invoiceTypeDropdown.getSelectedItem();
                if (type.equals("Purchase") || type.equals("Import")) {
                    dbService.loadSuppliers(customerDropdown, page, PAGE_SIZE);
                    totalCustomerPages = (int) Math.ceil((double) dbService.getSupplierCount() / PAGE_SIZE);
                } else {
                    dbService.loadCustomers(customerDropdown, page, PAGE_SIZE);
                    totalCustomerPages = (int) Math.ceil((double) dbService.getCustomerCount() / PAGE_SIZE);
                }
                SwingUtilities.invokeLater(() -> {
                    prevCustomerButton.setEnabled(page > 1);
                    nextCustomerButton.setEnabled(page < totalCustomerPages);
                    customerPageLabel.setText("Page " + page + " of " + totalCustomerPages);
                    filterCustomers();
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingCustomers", "Error loading customers/suppliers"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load customers/suppliers", this);
            return null;
        });
    }

    private void filterCustomers() {
        String query = customerSearch.getText().toLowerCase();
        customerDropdown.removeAllItems();
        String type = (String) invoiceTypeDropdown.getSelectedItem();
        Map<Integer, String> cache = type.equals("Purchase") || type.equals("Import") ? dbService.getSupplierCache() : dbService.getCustomerCache();
        cache.entrySet().stream()
            .filter(entry -> entry.getValue().toLowerCase().contains(query))
            .forEach(entry -> customerDropdown.addItem(entry.getKey() + " - " + entry.getValue()));
    }

    private void loadWarehouseOptions() {
        JComboBox<String> warehouseCombo = (JComboBox<String>) lineItemsTable.getColumnModel().getColumn(1).getCellEditor()
            .getTableCellEditorComponent(lineItemsTable, null, false, 0, 1);
        dbService.getWarehouseCache().forEach((id, name) -> warehouseCombo.addItem(id + " - " + name));
    }

    private void addLineItem() {
        CompletableFuture.runAsync(() -> {
            try {
                String productIdText = JOptionPane.showInputDialog(this, getMessage("enterProductId", "Enter Product ID"));
                int productId = ErrorHandler.validatePositiveInteger(productIdText, "Product ID");

                JComboBox<String> warehouseDropdown = new JComboBox<>();
                dbService.getWarehouseCache().forEach((id, name) -> warehouseDropdown.addItem(id + " - " + name));
                JOptionPane.showMessageDialog(this, warehouseDropdown, "Select Warehouse", JOptionPane.PLAIN_MESSAGE);
                String warehouseSelection = (String) warehouseDropdown.getSelectedItem();
                if (warehouseSelection == null) return;
                int warehouseId = Integer.parseInt(warehouseSelection.split(" - ")[0]);

                String quantityText = JOptionPane.showInputDialog(this, getMessage("enterQuantity", "Enter Quantity"));
                int quantity = ErrorHandler.validatePositiveInteger(quantityText, "Quantity");

                String[] units = {"Piece", "Box", "Kg", "Liter"};
                String unit = (String) JOptionPane.showInputDialog(this, "Select Unit", "Unit Selection",
                    JOptionPane.PLAIN_MESSAGE, null, units, units[0]);

                String[] currencies = {"USD", "IQD", "RMB"};
                String currency = (String) JOptionPane.showInputDialog(this, "Select Currency", "Currency Selection",
                    JOptionPane.PLAIN_MESSAGE, null, currencies, currencies[0]);

                String type = (String) invoiceTypeDropdown.getSelectedItem();
                boolean isPurchase = type.equals("Purchase") || type.equals("Import");
                InvoiceLineItem item = dbService.addLineItem(productId, warehouseId, quantity, unit, currency, isPurchase);
                if (item != null) {
                    Command addCommand = new AddLineItemCommand(item, warehouseSelection, currency);
                    SwingUtilities.invokeLater(() -> {
                        addCommand.execute();
                        undoStack.push(addCommand);
                        redoStack.clear();
                        auditService.logAction(currentUser, "invoicelineitems", String.valueOf(item.getId()), "Added line item to invoice: " + invoiceIdField.getText(), null, item.toString());
                    });
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add line item", this);
            return null;
        });
    }

    private void saveInvoice() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceType = (String) invoiceTypeDropdown.getSelectedItem();
                Integer customerId = null;
                if (!invoiceType.equals("Purchase") && !invoiceType.equals("Import")) {
                    ErrorHandler.validateRequiredField((String) customerDropdown.getSelectedItem(), "Customer");
                    customerId = Integer.parseInt(((String) customerDropdown.getSelectedItem()).split(" - ")[0]);
                } else {
                    ErrorHandler.validateRequiredField((String) customerDropdown.getSelectedItem(), "Supplier");
                    customerId = Integer.parseInt(((String) customerDropdown.getSelectedItem()).split(" - ")[0]);
                }
                String dateText = ((JTextField) datePicker.getJFormattedTextField()).getText();
                ErrorHandler.validateDate(dateText, "Date");
                double exchangeRate = ErrorHandler.validatePositiveDouble(exchangeRateField.getText(), "Exchange Rate");
                String paymentTerms = paymentTermsField.getText().equals("e.g., 30 days") ? "" : paymentTermsField.getText();
                String notes = notesArea.getText();
                String invoiceId = invoiceIdField.getText();
                List<InvoiceLineItem> lineItems = new ArrayList<>();
                double usdTotal = 0.0;
                for (int i = 0; i < lineItemsTableModel.getRowCount(); i++) {
                    Object totalPriceObj = lineItemsTableModel.getValueAt(i, 5);
                    if (!(totalPriceObj instanceof String) || ((String) totalPriceObj).isEmpty()) continue;
                    String currency = (String) lineItemsTableModel.getValueAt(i, 6);
                    double totalPrice = Double.parseDouble((String) totalPriceObj);
                    if (!"USD".equals(currency)) totalPrice = totalPrice / exchangeRate;
                    usdTotal += totalPrice;
                    int warehouseId = Integer.parseInt(((String) lineItemsTableModel.getValueAt(i, 1)).split(" - ")[0]);
                    lineItems.add(new InvoiceLineItem(
                        0,
                        Integer.parseInt(((String) lineItemsTableModel.getValueAt(i, 0)).split(": ")[1]),
                        warehouseId,
                        Integer.parseInt((String) lineItemsTableModel.getValueAt(i, 2)),
                        (String) lineItemsTableModel.getValueAt(i, 3),
                        Double.parseDouble((String) lineItemsTableModel.getValueAt(i, 4)),
                        totalPrice,
                        0, 0,
                        "USD"
                    ));
                }
                double totalAmount = usdTotal;

                if (isNewInvoiceMode) {
                    dbService.saveInvoice(customerId, invoiceType, dateText, totalAmount, "USD", lineItems, null, "USD", paymentTerms, "Pending", notes, exchangeRate);
                    auditService.logAction(currentUser, "invoices", invoiceId, "Saved new invoice: " + invoiceId, null, null);
                    if (recurringCheckBox.isSelected()) {
                        JTextField frequencyField = new JTextField("30", 5);
                        JTextField endDateField = new JTextField("yyyy-MM-dd", 10);
                        JPanel recurringPanel = new JPanel(new GridLayout(2, 2));
                        recurringPanel.add(new JLabel("Frequency (days):"));
                        recurringPanel.add(frequencyField);
                        recurringPanel.add(new JLabel("End Date:"));
                        recurringPanel.add(endDateField);
                        int result = JOptionPane.showConfirmDialog(this, recurringPanel, "Set Recurring Details", JOptionPane.OK_CANCEL_OPTION);
                        if (result == JOptionPane.OK_OPTION) {
                            int frequency = ErrorHandler.validatePositiveInteger(frequencyField.getText(), "Frequency");
                            String endDate = endDateField.getText();
                            ErrorHandler.validateDate(endDate, "End Date");
                            dbService.saveRecurringInvoice(invoiceId, frequency, dateText, endDate);
                            auditService.logAction(currentUser, "recurringinvoices", invoiceId, "Set invoice " + invoiceId + " as recurring", null, null);
                        }
                    }
                } else {
                    dbService.updateInvoice(invoiceId, customerId, invoiceType, dateText, totalAmount, "USD", lineItems, "USD", paymentTerms, "Pending", notes, exchangeRate);
                    auditService.logAction(currentUser, "invoices", invoiceId, "Updated invoice: " + invoiceId, null, null);
                }
                SwingUtilities.invokeLater(() ->
                    JOptionPane.showMessageDialog(this, getMessage("invoiceSavedSuccessfully", "Invoice saved successfully") + " (ID: " + invoiceId + ")"));
            } catch (ValidationException | DatabaseException | NumberFormatException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to save invoice", this);
            return null;
        });
    }

    private void viewInvoice() {
        CompletableFuture.runAsync(() -> {
            try {
                ErrorHandler.validateRequiredField(invoiceIdField.getText(), "Invoice ID");
                String invoiceId = invoiceIdField.getText();
                InvoiceDetails invoice = dbService.loadInvoiceDetails(invoiceId);
                if (invoice == null) {
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, getMessage("invoiceNotFound", "Invoice not found")));
                    return;
                }

                JDialog invoiceDialog = new JDialog(SwingUtilities.getWindowAncestor(this), getMessage("invoiceTitle", "Invoice") + invoiceId, true);
                invoiceDialog.setLayout(new BorderLayout());
                invoiceDialog.setSize(600, 500);

                JPanel summaryPanel = new JPanel(new GridLayout(10, 2, 5, 5));
                summaryPanel.add(new JLabel(getMessage("invoiceType", "Invoice Type")));
                summaryPanel.add(new JLabel(invoice.getInvoiceType()));
                summaryPanel.add(new JLabel(getMessage("customerSupplier", "Customer/Supplier")));
                summaryPanel.add(new JLabel(invoice.getCustomerName() != null ? invoice.getCustomerName() : "N/A"));
                summaryPanel.add(new JLabel(getMessage("date", "Date")));
                summaryPanel.add(new JLabel(invoice.getDate()));
                summaryPanel.add(new JLabel(getMessage("lastDebit", "Last Debit")));
                summaryPanel.add(new JLabel(String.format("%.2f USD", invoice.getLastDebit())));
                summaryPanel.add(new JLabel(getMessage("totalAmount", "Total Amount") + " (USD)"));
                summaryPanel.add(new JLabel(String.format("%.2f USD", invoice.getUsdTotal())));
                summaryPanel.add(new JLabel(getMessage("totalAmount", "Total Amount") + " (Local)"));
                summaryPanel.add(new JLabel(String.format("%.2f", invoice.getLocalTotal())));
                summaryPanel.add(new JLabel(getMessage("paymentTerms", "Payment Terms")));
                summaryPanel.add(new JLabel(invoice.getPaymentTerms()));
                summaryPanel.add(new JLabel(getMessage("deliveryStatus", "Delivery Status")));
                summaryPanel.add(new JLabel(invoice.getDeliveryStatus()));
                summaryPanel.add(new JLabel(getMessage("notes", "Notes")));
                summaryPanel.add(new JLabel(invoice.getNotes()));

                VirtualInvoiceTableModel viewModel = new VirtualInvoiceTableModel(dbService);
                viewModel.setAllRows(invoice.getLineItems());
                JTable lineItemsTable = new JTable(viewModel);
                JScrollPane scrollPane = new JScrollPane(lineItemsTable);
                scrollPane.getViewport().addChangeListener(e -> {
                    JViewport viewport = scrollPane.getViewport();
                    int rowHeight = lineItemsTable.getRowHeight();
                    int firstRow = viewport.getViewPosition().y / rowHeight;
                    int visibleRowCount = (int) Math.ceil((double) viewport.getHeight() / rowHeight) + 1;
                    viewModel.updateVisibleRows(firstRow, visibleRowCount);
                });

                invoiceDialog.add(summaryPanel, BorderLayout.NORTH);
                invoiceDialog.add(scrollPane, BorderLayout.CENTER);
                invoiceDialog.setLocationRelativeTo(this);
                SwingUtilities.invokeLater(() -> invoiceDialog.setVisible(true));
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to view invoice", this);
            return null;
        });
    }

    private void editInvoice() {
        CompletableFuture.runAsync(() -> {
            try {
                ErrorHandler.validateRequiredField(invoiceIdField.getText(), "Invoice ID");
                String invoiceId = invoiceIdField.getText();
                InvoiceDetails invoice = dbService.loadInvoiceDetails(invoiceId);
                if (invoice == null) {
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, getMessage("invoiceNotFound", "Invoice not found")));
                    return;
                }

                SwingUtilities.invokeLater(() -> {
                    invoiceTypeDropdown.setSelectedItem(invoice.getInvoiceType());
                    if (invoice.getCustomerName() != null) {
                        Map<Integer, String> cache = invoice.getInvoiceType().equals("Purchase") || invoice.getInvoiceType().equals("Import") ? 
                            dbService.getSupplierCache() : dbService.getCustomerCache();
                        customerDropdown.setSelectedItem(
                            cache.entrySet().stream()
                                .filter(e -> e.getValue().equals(invoice.getCustomerName()))
                                .map(e -> e.getKey() + " - " + e.getValue())
                                .findFirst().orElse(null)
                        );
                    }
                    ((JTextField) datePicker.getJFormattedTextField()).setText(invoice.getDate());
                    paymentTermsField.setText(invoice.getPaymentTerms());
                    notesArea.setText(invoice.getNotes());
                    lineItemsTableModel.setAllRows(invoice.getLineItems());
                    updateTotalAmounts();
                    JOptionPane.showMessageDialog(this, getMessage("invoiceLoadedForEdit", "Invoice loaded for editing"));
                });
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to edit invoice", this);
            return null;
        });
    }

    private void viewHistory() {
        CompletableFuture.runAsync(() -> {
            try {
                ErrorHandler.validateRequiredField(invoiceIdField.getText(), "Invoice ID");
                String invoiceId = invoiceIdField.getText();
                List<String> history = dbService.getInvoiceHistory(invoiceId);
                if (history.isEmpty()) {
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, getMessage("noHistoryFound", "No history found")));
                    return;
                }

                JTextArea historyArea = new JTextArea(10, 40);
                historyArea.setEditable(false);
                history.forEach(line -> historyArea.append(line + "\n"));
                SwingUtilities.invokeLater(() ->
                    JOptionPane.showMessageDialog(this, new JScrollPane(historyArea), getMessage("invoiceHistory", "Invoice History"), JOptionPane.INFORMATION_MESSAGE));
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to view history", this);
            return null;
        });
    }

    private void printInvoice() {
        try {
            boolean complete = lineItemsTable.print();
            SwingUtilities.invokeLater(() -> {
                if (complete) {
                    JOptionPane.showMessageDialog(this, getMessage("invoicePrintedSuccessfully", "Invoice printed successfully"));
                } else {
                    JOptionPane.showMessageDialog(this, getMessage("invoicePrintCancelled", "Invoice printing cancelled"));
                }
            });
        } catch (Exception e) {
            ErrorHandler.handleException(e, getMessage("errorPrintingInvoice", "Error printing invoice"), this);
        }
    }

    private void exportToPdf() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceId = invoiceIdField.getText();
                ErrorHandler.validateRequiredField(invoiceId, "Invoice ID");
                String type = (String) invoiceTypeDropdown.getSelectedItem();
                String customer = (String) customerDropdown.getSelectedItem();
                String date = ((JTextField) datePicker.getJFormattedTextField()).getText();
                String lastDebit = lastDebitField.getText();
                String usdTotal = usdTotalLabel.getText();
                String localTotal = localTotalLabel.getText();
                String paymentTerms = paymentTermsField.getText();
                String notes = notesArea.getText();
                String exchangeRate = exchangeRateField.getText();

                Document document = new Document();
                PdfWriter.getInstance(document, new FileOutputStream("Invoice_" + invoiceId + ".pdf"));
                document.open();
                document.add(new Paragraph(getMessage("invoiceDetails", "Invoice Details")));
                document.add(new Paragraph(getMessage("invoiceId", "Invoice ID") + ": " + invoiceId));
                document.add(new Paragraph(getMessage("invoiceType", "Invoice Type") + ": " + type));
                document.add(new Paragraph(getMessage("customerSupplier", "Customer/Supplier") + ": " + (customer != null ? customer : "N/A")));
                document.add(new Paragraph(getMessage("date", "Date") + ": " + date));
                document.add(new Paragraph(getMessage("lastDebit", "Last Debit") + ": " + lastDebit));
                document.add(new Paragraph(getMessage("totalAmount", "Total Amount") + " (USD): " + usdTotal));
                document.add(new Paragraph(getMessage("totalAmount", "Total Amount") + " (Local): " + localTotal));
                document.add(new Paragraph(getMessage("exchangeRate", "Exchange Rate") + " (to USD): " + exchangeRate));
                document.add(new Paragraph(getMessage("paymentTerms", "Payment Terms") + ": " + paymentTerms));
                document.add(new Paragraph(getMessage("notes", "Notes") + ": " + notes));
                document.add(new Paragraph(getMessage("lineItems", "Line Items")));
                for (int i = 0; i < lineItemsTableModel.getRowCount(); i++) {
                    if (lineItemsTableModel.getValueAt(i, 0) instanceof String && !((String) lineItemsTableModel.getValueAt(i, 0)).isEmpty()) {
                        document.add(new Paragraph(
                            lineItemsTableModel.getValueAt(i, 0) + " | " +
                            lineItemsTableModel.getValueAt(i, 1) + " | " +
                            lineItemsTableModel.getValueAt(i, 2) + " | " +
                            lineItemsTableModel.getValueAt(i, 3) + " | " +
                            lineItemsTableModel.getValueAt(i, 4) + " | " +
                            lineItemsTableModel.getValueAt(i, 5) + " | " +
                            lineItemsTableModel.getValueAt(i, 6)
                        ));
                    }
                }
                document.close();
                auditService.logAction(currentUser, "invoices", invoiceId, "Exported invoice to PDF: " + invoiceId, null, null);
                SwingUtilities.invokeLater(() ->
                    JOptionPane.showMessageDialog(this, getMessage("pdfExportedSuccessfully", "PDF exported successfully")));
            } catch (Exception e) {
                ErrorHandler.handleException(e, getMessage("errorExportingPdf", "Error exporting PDF"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to export PDF", this);
            return null;
        });
    }

    private void recordInvoicePayment() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceId = invoiceIdField.getText();
                ErrorHandler.validateRequiredField(invoiceId, "Invoice ID");

                String customer = (String) customerDropdown.getSelectedItem();
                if (customer == null || customer.isEmpty()) {
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, "Please select a customer/supplier first."));
                    return;
                }
                String customerName = customer.split(" - ")[1];
                int customerId = Integer.parseInt(customer.split(" - ")[0]);

                double currentDebitUSD = dbService.getCustomerDebit(customerId);

                JTextField amountField = new JTextField(10);
                JComboBox<String> currencyDropdown = new JComboBox<>(new String[]{"USD", "IQD", "RMB"});
                JPanel paymentPanel = new JPanel(new GridLayout(2, 2));
                paymentPanel.add(new JLabel("Payment Amount:"));
                paymentPanel.add(amountField);
                paymentPanel.add(new JLabel("Currency:"));
                paymentPanel.add(currencyDropdown);

                int result = JOptionPane.showConfirmDialog(this, paymentPanel, "Enter Payment for Customer " + customerName + " (Invoice " + invoiceId + ")", JOptionPane.OK_CANCEL_OPTION);
                if (result != JOptionPane.OK_OPTION) return;

                double amount = ErrorHandler.validatePositiveDouble(amountField.getText(), "Payment Amount");
                String paymentCurrency = (String) currencyDropdown.getSelectedItem();
                double exchangeRate = ErrorHandler.validatePositiveDouble(exchangeRateField.getText(), "Exchange Rate");

                double paymentInUSD = paymentCurrency.equals("USD") ? amount : amount / exchangeRate;
                if (paymentInUSD > currentDebitUSD) {
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, "Payment amount (" + paymentInUSD + " USD) exceeds customer debit (" + currentDebitUSD + " USD)."));
                    return;
                }

                dbService.markPaymentReceived(customerName, amount, paymentCurrency, exchangeRate, invoiceId);
                auditService.logAction(currentUser, "payments", null, "Payment of " + amount + " " + paymentCurrency + " received for customer: " + customerName + " (Invoice reference: " + invoiceId + ")", null, null);
                SwingUtilities.invokeLater(() -> {
                    JOptionPane.showMessageDialog(this, "Payment of " + amount + " " + paymentCurrency + " recorded for customer " + customerName);
                    updateDebitField();
                    int printOption = JOptionPane.showConfirmDialog(this, "Would you like to print the payment receipt?", "Print Receipt", JOptionPane.YES_NO_OPTION);
                    if (printOption == JOptionPane.YES_OPTION) {
                        printPaymentReceipt(customerName, amount, paymentCurrency, exchangeRate, invoiceId);
                    }
                });
            } catch (ValidationException | DatabaseException | NumberFormatException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to record payment", this);
            return null;
        });
    }

    private void printPaymentReceipt(String customerName, double amount, String currency, double exchangeRate, String invoiceId) {
        try {
            JTextArea receiptArea = new JTextArea(10, 40);
            receiptArea.setEditable(false);
            receiptArea.append("Payment Receipt\n");
            receiptArea.append("------------------------\n");
            receiptArea.append("Customer: " + customerName + "\n");
            receiptArea.append("Invoice Reference: " + invoiceId + "\n");
            receiptArea.append("Amount: " + String.format("%.2f", amount) + " " + currency + "\n");
            receiptArea.append("Exchange Rate (to USD): " + String.format("%.2f", exchangeRate) + "\n");
            receiptArea.append("Amount in USD: " + String.format("%.2f", currency.equals("USD") ? amount : amount / exchangeRate) + " USD\n");
            receiptArea.append("Date: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()) + "\n");
            receiptArea.append("------------------------\n");

            boolean complete = receiptArea.print();
            if (complete) {
                auditService.logAction(currentUser, "payments", null, "Printed payment receipt for customer: " + customerName + ", Invoice: " + invoiceId, null, null);
                JOptionPane.showMessageDialog(this, "Payment receipt printed successfully.");
            } else {
                JOptionPane.showMessageDialog(this, "Payment receipt printing cancelled.");
            }

            int pdfOption = JOptionPane.showConfirmDialog(this, "Would you like to save the receipt as PDF?", "Save as PDF", JOptionPane.YES_NO_OPTION);
            if (pdfOption == JOptionPane.YES_OPTION) {
                Document document = new Document();
                PdfWriter.getInstance(document, new FileOutputStream("Payment_Receipt_" + invoiceId + "_" + System.currentTimeMillis() + ".pdf"));
                document.open();
                document.add(new Paragraph(receiptArea.getText()));
                document.close();
                auditService.logAction(currentUser, "payments", null, "Exported payment receipt to PDF for customer: " + customerName + ", Invoice: " + invoiceId, null, null);
                JOptionPane.showMessageDialog(this, "Payment receipt saved as PDF.");
            }
        } catch (Exception e) {
            ErrorHandler.handleException(e, "Failed to print or save payment receipt", this);
        }
    }

    private void updateTotalAmounts() {
        double usdTotal = 0.0, localTotal = 0.0;
        double exchangeRate;
        try {
            exchangeRate = Double.parseDouble(exchangeRateField.getText());
        } catch (NumberFormatException e) {
            exchangeRate = 1.0;
        }
        for (int i = 0; i < lineItemsTableModel.getRowCount(); i++) {
            Object totalPriceObj = lineItemsTableModel.getValueAt(i, 5);
            if (!(totalPriceObj instanceof String) || ((String) totalPriceObj).isEmpty()) continue;
            double totalPrice = Double.parseDouble((String) totalPriceObj);
            String currency = (String) lineItemsTableModel.getValueAt(i, 6);
            if ("USD".equals(currency)) {
                usdTotal += totalPrice;
                localTotal += totalPrice * exchangeRate;
            } else {
                localTotal += totalPrice;
                usdTotal += totalPrice / exchangeRate;
            }
        }
        double lastDebit = getLastDebit();
        usdTotalLabel.setText(String.format("%.2f", usdTotal));
        localTotalLabel.setText(String.format("%.2f", localTotal));
        lastDebitField.setText(String.format("%.2f", lastDebit));
    }

    private double getLastDebit() {
        try {
            String customer = (String) customerDropdown.getSelectedItem();
            String type = (String) invoiceTypeDropdown.getSelectedItem();
            if (customer !=            null && !customer.isEmpty() && !type.equals("Purchase") && !type.equals("Import")) {
                int customerId = Integer.parseInt(customer.split(" - ")[0]);
                return dbService.getCustomerDebit(customerId);
            }
            return 0.0;
        } catch (DatabaseException | NumberFormatException e) {
            ErrorHandler.handleException(e, getMessage("errorFetchingDebit", "Error fetching debit"), this);
            return 0.0;
        }
    }

    private void updateDebitField() {
        updateTotalAmounts();
    }

    private void undo() {
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
            auditService.logAction(currentUser, "invoices", invoiceIdField.getText(), "Undid action in invoice: " + invoiceIdField.getText(), null, null);
        }
    }

    private void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
            auditService.logAction(currentUser, "invoices", invoiceIdField.getText(), "Redid action in invoice: " + invoiceIdField.getText(), null, null);
        }
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private class AddLineItemCommand implements Command {
        private final InvoiceLineItem item;
        private final String warehouseSelection;
        private final String currency;

        AddLineItemCommand(InvoiceLineItem item, String warehouseSelection, String currency) {
            this.item = item;
            this.warehouseSelection = warehouseSelection;
            this.currency = currency;
        }

        @Override
        public void execute() {
            lineItemsTableModel.addRow(item);
            updateTotalAmounts();
        }

        @Override
        public void undo() {
            for (int i = 0; i < lineItemsTableModel.getRowCount(); i++) {
                if (lineItemsTableModel.getValueAt(i, 0).equals(item.getDescription())) {
                    lineItemsTableModel.removeRow(i);
                    break;
                }
            }
            updateTotalAmounts();
        }
    }
}

/**
 * Command interface for undo/redo support.
 */
interface Command {
    void execute();
    void undo();
}

/**
 * Renderer for the "+" button in the JTable.
 */
class ButtonRenderer extends DefaultTableCellRenderer {
    private final JButton button = new JButton("+");

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        button.setToolTipText("Add a new line item");
        button.getAccessibleContext().setAccessibleName("Add Line Item Button");
        return button;
    }
}

/**
 * Editor for the "+" button in the JTable.
 */
class ButtonEditor extends DefaultCellEditor {
    private final JButton button;
    private final Runnable action;

    public ButtonEditor(JCheckBox checkBox, Runnable action) {
        super(checkBox);
        this.button = new JButton("+");
        this.action = action;
        button.addActionListener(e -> action.run());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        button.setToolTipText("Add a new line item");
        button.getAccessibleContext().setAccessibleName("Add Line Item Button");
        return button;
    }

    @Override
    public Object getCellEditorValue() {
        return "+";
    }
}

/**
 * Virtual Table Model for RecurringInvoicePanel with caching
 */
class VirtualRecurringInvoiceTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final List<RecurringInvoice> visibleRows = new ArrayList<>();
    private final Map<Integer, List<RecurringInvoice>> pageCache = new LinkedHashMap<Integer, List<RecurringInvoice>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<RecurringInvoice>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualRecurringInvoiceTableModel(DatabaseService dbService, int pageSize) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = dbService.getRecurringInvoiceCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<RecurringInvoice> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getRecurringInvoices(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 5; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        RecurringInvoice invoice = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return invoice.getInvoiceId();
            case 1: return invoice.getFrequency();
            case 2: return invoice.getNextDate();
            case 3: return invoice.getEndDate();
            case 4: return invoice.getLastGenerated();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Invoice ID";
            case 1: return "Frequency (days)";
            case 2: return "Next Date";
            case 3: return "End Date";
            case 4: return "Last Generated";
            default: return "";
        }
    }
}

/**
 * Panel for managing recurring invoices with virtual scrolling and caching.
 */
class RecurringInvoicePanel extends JPanel {
    private static final int PAGE_SIZE = 50;
    private JTable recurringTable;
    private VirtualRecurringInvoiceTableModel recurringTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int recurringPage = 1;
    private int totalRecurringPages = 1;
    private JButton prevButton, nextButton;
    private JLabel recurringPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public RecurringInvoicePanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        recurringTableModel = new VirtualRecurringInvoiceTableModel(dbService, PAGE_SIZE);
        recurringTable = new JTable(recurringTableModel);
        recurringTable.setToolTipText(getMessage("recurringInvoices"));
        recurringTable.getAccessibleContext().setAccessibleName("Recurring Invoices Table");
        scrollPane = new JScrollPane(recurringTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadRecurringInvoices());
        refreshButton.setToolTipText("Refresh recurring invoices list");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Button");
        buttonPanel.add(refreshButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (recurringPage > 1) {
                recurringPage--;
                loadRecurringInvoices();
            }
        });
        prevButton.setToolTipText("Previous page of recurring invoices");
        prevButton.getAccessibleContext().setAccessibleName("Previous Page Button");
        buttonPanel.add(prevButton);

        recurringPageLabel = new JLabel("Page " + recurringPage + " of " + totalRecurringPages);
        recurringPageLabel.setToolTipText("Current recurring invoice page");
        recurringPageLabel.getAccessibleContext().setAccessibleName("Page Indicator");
        buttonPanel.add(recurringPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (recurringPage < totalRecurringPages) {
                recurringPage++;
                loadRecurringInvoices();
            }
        });
        nextButton.setToolTipText("Next page of recurring invoices");
        nextButton.getAccessibleContext().setAccessibleName("Next Page Button");
        buttonPanel.add(nextButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadRecurringInvoices();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void loadRecurringInvoices() {
        CompletableFuture.runAsync(() -> {
            try {
                totalRecurringPages = (int) Math.ceil((double) dbService.getRecurringInvoiceCount() / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(recurringPage > 1);
                    nextButton.setEnabled(recurringPage < totalRecurringPages);
                    recurringPageLabel.setText("Page " + recurringPage + " of " + totalRecurringPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingRecurringInvoices", "Error loading recurring invoices"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load recurring invoices", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = recurringTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        recurringTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for InventoryPanel with caching
 */
class VirtualInventoryTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final List<InventoryItem> visibleRows = new ArrayList<>();
    private final Map<Integer, List<InventoryItem>> pageCache = new LinkedHashMap<Integer, List<InventoryItem>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<InventoryItem>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualInventoryTableModel(DatabaseService dbService, int pageSize) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = dbService.getInventoryCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<InventoryItem> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getInventoryItems(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 3; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        InventoryItem item = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return item.getProductId();
            case 1: return item.getWarehouseId();
            case 2: return item.getQuantity();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Product";
            case 1: return "Warehouse";
            case 2: return "Quantity";
            default: return "";
        }
    }
}

/**
 * Panel for managing inventory with virtual scrolling and caching.
 */
class InventoryPanel extends JPanel {
    private static final int PAGE_SIZE = 100;
    private JTable inventoryTable;
    private VirtualInventoryTableModel inventoryTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int inventoryPage = 1;
    private int totalInventoryPages = 1;
    private JButton prevButton, nextButton;
    private JLabel inventoryPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public InventoryPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        inventoryTableModel = new VirtualInventoryTableModel(dbService, PAGE_SIZE);
        inventoryTable = new JTable(inventoryTableModel);
        inventoryTable.setToolTipText(getMessage("currentInventoryItems"));
        inventoryTable.getAccessibleContext().setAccessibleName("Inventory Table");
        scrollPane = new JScrollPane(inventoryTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addButton = new JButton(getMessage("addInventoryItem", "Add Inventory Item"));
        addButton.addActionListener(e -> addInventoryItem());
        addButton.setToolTipText("Add a new inventory item");
        addButton.getAccessibleContext().setAccessibleName("Add Inventory Item Button");
        buttonPanel.add(addButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (inventoryPage > 1) {
                inventoryPage--;
                loadInventory();
            }
        });
        prevButton.setToolTipText("Previous page of inventory");
        prevButton.getAccessibleContext().setAccessibleName("Previous Inventory Page Button");
        buttonPanel.add(prevButton);

        inventoryPageLabel = new JLabel("Page " + inventoryPage + " of " + totalInventoryPages);
        inventoryPageLabel.setToolTipText("Current inventory page");
        inventoryPageLabel.getAccessibleContext().setAccessibleName("Inventory Page Indicator");
        buttonPanel.add(inventoryPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (inventoryPage < totalInventoryPages) {
                inventoryPage++;
                loadInventory();
            }
        });
        nextButton.setToolTipText("Next page of inventory");
        nextButton.getAccessibleContext().setAccessibleName("Next Inventory Page Button");
        buttonPanel.add(nextButton);

        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadInventory());
        refreshButton.setToolTipText("Refresh inventory list");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Inventory Button");
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadInventory();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void addInventoryItem() {
        CompletableFuture.runAsync(() -> {
            try {
                String productIdText = JOptionPane.showInputDialog(this, getMessage("enterProductId", "Enter Product ID"));
                int productId = ErrorHandler.validatePositiveInteger(productIdText, "Product ID");

                String warehouseIdText = JOptionPane.showInputDialog(this, getMessage("enterWarehouseId", "Enter Warehouse ID"));
                int warehouseId = ErrorHandler.validatePositiveInteger(warehouseIdText, "Warehouse ID");

                String quantityText = JOptionPane.showInputDialog(this, getMessage("enterQuantity", "Enter Quantity"));
                int quantity = ErrorHandler.validatePositiveInteger(quantityText, "Quantity");

                dbService.addInventoryItem(productId, warehouseId, quantity);
                auditService.logAction(currentUser, "inventory", null, "Added inventory item: Product " + productId + ", Warehouse " + warehouseId, null, null);
                inventoryTableModel.invalidateCache();
                loadInventory();
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add inventory item", this);
            return null;
        });
    }

    private void loadInventory() {
        CompletableFuture.runAsync(() -> {
            try {
                totalInventoryPages = (int) Math.ceil((double) dbService.getInventoryCount() / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(inventoryPage > 1);
                    nextButton.setEnabled(inventoryPage < totalInventoryPages);
                    inventoryPageLabel.setText("Page " + inventoryPage + " of " + totalInventoryPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingInventory", "Error loading inventory"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load inventory", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = inventoryTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        inventoryTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for AttachmentPanel with caching
 */
class VirtualAttachmentTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final String invoiceId;
    private final List<Attachment> visibleRows = new ArrayList<>();
    private final Map<Integer, List<Attachment>> pageCache = new LinkedHashMap<Integer, List<Attachment>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<Attachment>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualAttachmentTableModel(DatabaseService dbService, int pageSize, String invoiceId) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        this.invoiceId = invoiceId;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = invoiceId != null ? dbService.getAttachmentCount(invoiceId) : 0;
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        if (invoiceId == null) return;
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<Attachment> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getAttachments(invoiceId, page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 3; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        Attachment attachment = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return attachment.getFileName();
            case 1: return attachment.getFileSize();
            case 2: return attachment.getUploadDate();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "File Name";
            case 1: return "File Size";
            case 2: return "Upload Date";
            default: return "";
        }
    }
}

/**
 * Panel for managing attachments with virtual scrolling and caching.
 */
class AttachmentPanel extends JPanel {
    private static final int PAGE_SIZE = 100;
    private JTable attachmentsTable;
    private VirtualAttachmentTableModel attachmentsTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int attachmentPage = 1;
    private int totalAttachmentPages = 1;
    private String currentInvoiceId;
    private JButton prevButton, nextButton;
    private JLabel attachmentPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public AttachmentPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        attachmentsTableModel = new VirtualAttachmentTableModel(dbService, PAGE_SIZE, null);
        attachmentsTable = new JTable(attachmentsTableModel);
        attachmentsTable.setToolTipText(getMessage("attachmentsForTheCurrentInvoice"));
        attachmentsTable.getAccessibleContext().setAccessibleName("Attachments Table");
        scrollPane = new JScrollPane(attachmentsTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addButton = new JButton(getMessage("addAttachment", "Add Attachment"));
        addButton.addActionListener(e -> addAttachment());
        addButton.setToolTipText("Add a new attachment to an invoice");
        addButton.getAccessibleContext().setAccessibleName("Add Attachment Button");
        buttonPanel.add(addButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (attachmentPage > 1) {
                attachmentPage--;
                loadAttachments(currentInvoiceId);
            }
        });
        prevButton.setToolTipText("Previous page of attachments");
        prevButton.getAccessibleContext().setAccessibleName("Previous Attachment Page Button");
        buttonPanel.add(prevButton);

        attachmentPageLabel = new JLabel("Page " + attachmentPage + " of " + totalAttachmentPages);
        attachmentPageLabel.setToolTipText("Current attachment page");
        attachmentPageLabel.getAccessibleContext().setAccessibleName("Attachment Page Indicator");
        buttonPanel.add(attachmentPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (attachmentPage < totalAttachmentPages) {
                attachmentPage++;
                loadAttachments(currentInvoiceId);
            }
        });
        nextButton.setToolTipText("Next page of attachments");
        nextButton.getAccessibleContext().setAccessibleName("Next Attachment Page Button");
        buttonPanel.add(nextButton);

        add(buttonPanel, BorderLayout.SOUTH);
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void addAttachment() {
        CompletableFuture.runAsync(() -> {
            try {
                String invoiceIdText = JOptionPane.showInputDialog(this, getMessage("enterInvoiceId", "Enter Invoice ID"));
                ErrorHandler.validateRequiredField(invoiceIdText, "Invoice ID");

                JFileChooser fileChooser = new JFileChooser();
                if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
                    File file = fileChooser.getSelectedFile();
                    String uploadDate = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
                    dbService.addAttachment(invoiceIdText, file.getName(), file.length(), uploadDate);
                    auditService.logAction(currentUser, "attachments", null, "Added attachment to invoice: " + invoiceIdText, null, null);
                    currentInvoiceId = invoiceIdText;
                    attachmentsTableModel = new VirtualAttachmentTableModel(dbService, PAGE_SIZE, currentInvoiceId);
                    attachmentsTable.setModel(attachmentsTableModel);
                    attachmentsTableModel.invalidateCache();
                    loadAttachments(invoiceIdText);
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add attachment", this);
            return null;
        });
    }

    private void loadAttachments(String invoiceId) {
        CompletableFuture.runAsync(() -> {
            try {
                totalAttachmentPages = (int) Math.ceil((double) dbService.getAttachmentCount(invoiceId) / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(attachmentPage > 1);
                    nextButton.setEnabled(attachmentPage < totalAttachmentPages);
                    attachmentPageLabel.setText("Page " + attachmentPage + " of " + totalAttachmentPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingAttachments", "Error loading attachments"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load attachments", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = attachmentsTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        attachmentsTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for ContactsPanel with caching
 */
class VirtualContactsTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final boolean isSupplier;
    private final List<Contact> visibleRows = new ArrayList<>();
    private final Map<Integer, List<Contact>> pageCache = new LinkedHashMap<Integer, List<Contact>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<Contact>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualContactsTableModel(DatabaseService dbService, int pageSize, boolean isSupplier) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        this.isSupplier = isSupplier;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = isSupplier ? dbService.getSupplierCount() : dbService.getCustomerCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<Contact> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = isSupplier ? dbService.getSuppliers(page, pageSize) : dbService.getCustomers(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 5; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        Contact contact = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return contact.getId();
            case 1: return contact.getName();
            case 2: return contact.getContact();
            case 3: return contact.getEmail();
            case 4: return contact.getAddress();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "ID";
            case 1: return "Name";
            case 2: return "Contact";
            case 3: return "Email";
            case 4: return "Address";
            default: return "";
        }
    }
}

/**
 * Panel for managing customers and suppliers.
 */
class ContactsPanel extends JPanel {
    private static final int PAGE_SIZE = 50;
    private JTable contactsTable;
    private VirtualContactsTableModel contactsTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int contactsPage = 1;
    private int totalContactsPages = 1;
    private JButton prevButton, nextButton;
    private JLabel contactsPageLabel;
    private JScrollPane scrollPane;
    private JComboBox<String> typeCombo;
    private String currentUser = "User1";

    public ContactsPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        typeCombo = new JComboBox<>(new String[]{getMessage("customers", "Customers"), getMessage("suppliers", "Suppliers")});
        typeCombo.addActionListener(e -> {
            contactsTableModel = new VirtualContactsTableModel(dbService, PAGE_SIZE, typeCombo.getSelectedIndex() == 1);
            contactsTable.setModel(contactsTableModel);
            loadContacts();
        });
        add(typeCombo, BorderLayout.NORTH);

        contactsTableModel = new VirtualContactsTableModel(dbService, PAGE_SIZE, false);
        contactsTable = new JTable(contactsTableModel);
        contactsTable.setToolTipText(getMessage("customersAndSuppliers"));
        contactsTable.getAccessibleContext().setAccessibleName("Contacts Table");
        scrollPane = new JScrollPane(contactsTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addButton = new JButton(getMessage("addContact", "Add Contact"));
        addButton.addActionListener(e -> addContact());
        addButton.setToolTipText("Add a new customer or supplier");
        addButton.getAccessibleContext().setAccessibleName("Add Contact Button");
        buttonPanel.add(addButton);

        JButton editButton = new JButton(getMessage("editContact", "Edit Contact"));
        editButton.addActionListener(e -> editContact());
        editButton.setToolTipText("Edit selected contact");
        editButton.getAccessibleContext().setAccessibleName("Edit Contact Button");
        buttonPanel.add(editButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (contactsPage > 1) {
                contactsPage--;
                loadContacts();
            }
        });
        prevButton.setToolTipText("Previous page of contacts");
        prevButton.getAccessibleContext().setAccessibleName("Previous Contacts Page Button");
        buttonPanel.add(prevButton);

        contactsPageLabel = new JLabel("Page " + contactsPage + " of " + totalContactsPages);
        contactsPageLabel.setToolTipText("Current contacts page");
        contactsPageLabel.getAccessibleContext().setAccessibleName("Contacts Page Indicator");
        buttonPanel.add(contactsPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (contactsPage < totalContactsPages) {
                contactsPage++;
                loadContacts();
            }
        });
        nextButton.setToolTipText("Next page of contacts");
        nextButton.getAccessibleContext().setAccessibleName("Next Contacts Page Button");
        buttonPanel.add(nextButton);

        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadContacts());
        refreshButton.setToolTipText("Refresh contacts list");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Contacts Button");
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadContacts();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void addContact() {
        CompletableFuture.runAsync(() -> {
            try {
                JTextField nameField = new JTextField(20);
                JTextField contactField = new JTextField(20);
                JTextField emailField = new JTextField(20);
                JTextField addressField = new JTextField(20);
                JPanel panel = new JPanel(new GridLayout(4, 2));
                panel.add(new JLabel(getMessage("name", "Name")));
                panel.add(nameField);
                panel.add(new JLabel(getMessage("contact", "Contact")));
                panel.add(contactField);
                panel.add(new JLabel(getMessage("email", "Email")));
                panel.add(emailField);
                panel.add(new JLabel(getMessage("address", "Address")));
                panel.add(addressField);

                int result = JOptionPane.showConfirmDialog(this, panel, "Add Contact", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    String name = nameField.getText();
                    ErrorHandler.validateRequiredField(name, "Name");
                    String contact = contactField.getText();
                    String email = emailField.getText();
                    String address = addressField.getText();
                    boolean isSupplier = typeCombo.getSelectedIndex() == 1;
                    if (isSupplier) {
                        dbService.addSupplier(name, contact, email, address);
                        auditService.logAction(currentUser, "suppliers", null, "Added supplier: " + name, null, null);
                    } else {
                        dbService.addCustomer(name, contact, email, address);
                        auditService.logAction(currentUser, "customers", null, "Added customer: " + name, null, null);
                    }
                    contactsTableModel.invalidateCache();
                    loadContacts();
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add contact", this);
            return null;
        });
    }

    private void editContact() {
        int selectedRow = contactsTable.getSelectedRow();
        if (selectedRow == -1) {
            JOptionPane.showMessageDialog(this, "Please select a contact to edit.");
            return;
        }
        Contact contact = contactsTableModel.visibleRows.get(selectedRow - firstVisibleRow);

        CompletableFuture.runAsync(() -> {
            try {
                JTextField nameField = new JTextField(contact.getName(), 20);
                JTextField contactField = new JTextField(contact.getContact(), 20);
                JTextField emailField = new JTextField(contact.getEmail(), 20);
                JTextField addressField = new JTextField(contact.getAddress(), 20);
                JPanel panel = new JPanel(new GridLayout(4, 2));
                panel.add(new JLabel(getMessage("name", "Name")));
                panel.add(nameField);
                panel.add(new JLabel(getMessage("contact", "Contact")));
                panel.add(contactField);
                panel.add(new JLabel(getMessage("email", "Email")));
                panel.add(emailField);
                panel.add(new JLabel(getMessage("address", "Address")));
                panel.add(addressField);

                int result = JOptionPane.showConfirmDialog(this, panel, "Edit Contact", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    String name = nameField.getText();
                    ErrorHandler.validateRequiredField(name, "Name");
                    String newContact = contactField.getText();
                    String newEmail = emailField.getText();
                    String newAddress = addressField.getText();
                    boolean isSupplier = typeCombo.getSelectedIndex() == 1;
                    if (isSupplier) {
                        dbService.updateSupplier(contact.getId(), name, newContact, newEmail, newAddress);
                        auditService.logAction(currentUser, "suppliers", String.valueOf(contact.getId()), "Updated supplier: " + name, contact.toString(), new Contact(contact.getId(), name, newContact, newEmail, newAddress).toString());
                    } else {
                        dbService.updateCustomer(contact.getId(), name, newContact, newEmail, newAddress);
                        auditService.logAction(currentUser, "customers", String.valueOf(contact.getId()), "Updated customer: " + name, contact.toString(), new Contact(contact.getId(), name, newContact, newEmail, newAddress).toString());
                    }
                    contactsTableModel.invalidateCache();
                    loadContacts();
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to edit contact", this);
            return null;
        });
    }

    private void loadContacts() {
        CompletableFuture.runAsync(() -> {
            try {
                totalContactsPages = (int) Math.ceil((double) (typeCombo.getSelectedIndex() == 1 ? dbService.getSupplierCount() : dbService.getCustomerCount()) / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(contactsPage > 1);
                    nextButton.setEnabled(contactsPage < totalContactsPages);
                    contactsPageLabel.setText("Page " + contactsPage + " of " + totalContactsPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingContacts", "Error loading contacts"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load contacts", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = contactsTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        contactsTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for ExpensesPanel with caching
 */
class VirtualExpensesTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final List<Expense> visibleRows = new ArrayList<>();
    private final Map<Integer, List<Expense>> pageCache = new LinkedHashMap<Integer, List<Expense>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<Expense>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualExpensesTableModel(DatabaseService dbService, int pageSize) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = dbService.getExpenseCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<Expense> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getExpenses(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 5; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        Expense expense = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return expense.getDescription();
            case 1: return expense.getAmount();
            case 2: return expense.getCurrency();
            case 3: return expense.getCategory();
            case 4: return expense.getDate();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Description";
            case 1: return "Amount";
            case 2: return "Currency";
            case 3: return "Category";
            case 4: return "Date";
            default: return "";
        }
    }
}

/**
 * Panel for managing expenses and budgets with virtual scrolling and caching.
 */
class ExpensesPanel extends JPanel {
    private static final int PAGE_SIZE = 100;
    private JTable expensesTable;
    private VirtualExpensesTableModel expensesTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int expensesPage = 1;
    private int totalExpensesPages = 1;
    private JButton prevButton, nextButton;
    private JLabel expensesPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public ExpensesPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        expensesTableModel = new VirtualExpensesTableModel(dbService, PAGE_SIZE);
        expensesTable = new JTable(expensesTableModel);
        expensesTable.setToolTipText(getMessage("expenseRecords"));
        expensesTable.getAccessibleContext().setAccessibleName("Expenses Table");
        scrollPane = new JScrollPane(expensesTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addExpenseButton = new JButton(getMessage("addExpense", "Add Expense"));
        addExpenseButton.addActionListener(e -> addExpense());
        addExpenseButton.setToolTipText("Add a new expense");
        addExpenseButton.getAccessibleContext().setAccessibleName("Add Expense Button");
        buttonPanel.add(addExpenseButton);

        JButton setBudgetButton = new JButton(getMessage("setBudget", "Set Budget"));
        setBudgetButton.addActionListener(e -> setBudget());
        setBudgetButton.setToolTipText("Set a budget for a category");
        setBudgetButton.getAccessibleContext().setAccessibleName("Set Budget Button");
        buttonPanel.add(setBudgetButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (expensesPage > 1) {
                expensesPage--;
                loadExpenses();
            }
        });
        prevButton.setToolTipText("Previous page of expenses");
        prevButton.getAccessibleContext().setAccessibleName("Previous Expenses Page Button");
        buttonPanel.add(prevButton);

        expensesPageLabel = new JLabel("Page " + expensesPage + " of " + totalExpensesPages);
        expensesPageLabel.setToolTipText("Current expenses page");
        expensesPageLabel.getAccessibleContext().setAccessibleName("Expenses Page Indicator");
        buttonPanel.add(expensesPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (expensesPage < totalExpensesPages) {
                expensesPage++;
                loadExpenses();
            }
        });
        nextButton.setToolTipText("Next page of expenses");
        nextButton.getAccessibleContext().setAccessibleName("Next Expenses Page Button");
        buttonPanel.add(nextButton);

        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadExpenses());
        refreshButton.setToolTipText("Refresh expenses list");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Expenses Button");
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadExpenses();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void addExpense() {
        CompletableFuture.runAsync(() -> {
            try {
                JTextField descField = new JTextField(20);
                JTextField amountField = new JTextField(10);
                JComboBox<String> currencyDropdown = new JComboBox<>(new String[]{"USD", "IQD", "RMB"});
                JComboBox<String> categoryDropdown = new JComboBox<>(new String[]{"Utilities", "Salaries", "Supplies", "Other"});
                JDatePickerImpl datePicker = new JDatePickerImpl(new JDatePanelImpl(new UtilDateModel(), new Properties()), new DateLabelFormatter());
                JPanel panel = new JPanel(new GridLayout(5, 2));
                panel.add(new JLabel(getMessage("description", "Description")));
                panel.add(descField);
                panel.add(new JLabel(getMessage("amount", "Amount")));
                panel.add(amountField);
                panel.add(new JLabel(getMessage("currency", "Currency")));
                panel.add(currencyDropdown);
                panel.add(new JLabel(getMessage("category", "Category")));
                panel.add(categoryDropdown);
                panel.add(new JLabel(getMessage("date", "Date")));
                panel.add(datePicker);

                int result = JOptionPane.showConfirmDialog(this, panel, "Add Expense", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    String description = descField.getText();
                    ErrorHandler.validateRequiredField(description, "Description");
                    double amount = ErrorHandler.validatePositiveDouble(amountField.getText(), "Amount");
                    String currency = (String) currencyDropdown.getSelectedItem();
                    String category = (String) categoryDropdown.getSelectedItem();
                    String date = ((JTextField) datePicker.getJFormattedTextField()).getText();
                    ErrorHandler.validateDate(date, "Date");

                    dbService.addExpense(description, amount, currency, category, date);
                    auditService.logAction(currentUser, "cashtransactions", null, "Added expense: " + description, null, null);
                    expensesTableModel.invalidateCache();
                    loadExpenses();

                    double budgetLimit = dbService.getBudgetLimit(category);
                    double totalSpent = dbService.getTotalExpensesByCategory(category);
                    if (budgetLimit > 0 && totalSpent > budgetLimit * 0.8) {
                        SwingUtilities.invokeLater(() ->
                            JOptionPane.showMessageDialog(this, "Warning: " + category + " expenses nearing budget limit (" + totalSpent + "/" + budgetLimit + " USD)"));
                    }
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add expense", this);
            return null;
        });
    }

    private void setBudget() {
        CompletableFuture.runAsync(() -> {
            try {
                JComboBox<String> categoryDropdown = new JComboBox<>(new String[]{"Utilities", "Salaries", "Supplies", "Other"});
                JTextField amountField = new JTextField(10);
                JPanel panel = new JPanel(new GridLayout(2, 2));
                panel.add(new JLabel(getMessage("category", "Category")));
                panel.add(categoryDropdown);
                panel.add(new JLabel(getMessage("budgetAmount", "Budget Amount (USD)")));
                panel.add(amountField);

                int result = JOptionPane.showConfirmDialog(this, panel, "Set Budget", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    String category = (String) categoryDropdown.getSelectedItem();
                    double amount = ErrorHandler.validatePositiveDouble(amountField.getText(), "Budget Amount");
                    dbService.setBudget(category, amount);
                    auditService.logAction(currentUser, "budgets", null, "Set budget for " + category + ": " + amount + " USD", null, null);
                    SwingUtilities.invokeLater(() ->
                        JOptionPane.showMessageDialog(this, "Budget set for " + category + ": " + amount + " USD"));
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to set budget", this);
            return null;
        });
    }

    private void loadExpenses() {
        CompletableFuture.runAsync(() -> {
            try {
                totalExpensesPages = (int) Math.ceil((double) dbService.getExpenseCount() / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(expensesPage > 1);
                    nextButton.setEnabled(expensesPage < totalExpensesPages);
                    expensesPageLabel.setText("Page " + expensesPage + " of " + totalExpensesPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingExpenses", "Error loading expenses"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load expenses", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = expensesTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        expensesTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for ReportPanel with caching
 */
class VirtualReportTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final List<Object[]> allRows = new ArrayList<>();
    private final List<Object[]> visibleRows = new ArrayList<>();
    private final Map<Integer, List<Object[]>> pageCache = new LinkedHashMap<Integer, List<Object[]>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<Object[]>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;
    private static final int PAGE_SIZE = 50;

    public void setAllRows(List<Object[]> rows) {
        allRows.clear();
        allRows.addAll(rows);
        totalRowCount = allRows.size();
        pageCache.clear();
        fireTableDataChanged();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / PAGE_SIZE) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / PAGE_SIZE) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<Object[]> pageData = pageCache.get(page);
            if (pageData == null) {
                int startIndex = (page - 1) * PAGE_SIZE;
                int endIndex = Math.min(page * PAGE_SIZE, allRows.size());
                pageData = allRows.subList(startIndex, endIndex);
                pageCache.put(page, pageData);
            }
            int startIndex = (page == startPage) ? firstVisibleRow % PAGE_SIZE : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % PAGE_SIZE + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 2; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        Object[] row = visibleRows.get(rowIndex - firstVisibleRow);
        return row[columnIndex];
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Metric";
            case 1: return "Value";
            default: return "";
        }
    }
}

/**
 * Panel for advanced reporting with virtual scrolling and caching.
 */
class ReportPanel extends JPanel {
    private JTable reportTable;
    private VirtualReportTableModel reportTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private JDatePickerImpl startDatePicker, endDatePicker;
    private JPanel chartPanel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public ReportPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        JPanel filterPanel = new JPanel(new FlowLayout());
        JLabel startLabel = new JLabel(getMessage("startDate", "Start Date"));
        startLabel.getAccessibleContext().setAccessibleName("Start Date Label");
        filterPanel.add(startLabel);
        UtilDateModel startModel = new UtilDateModel();
        Properties p = new Properties();
        p.put("text.today", getMessage("today", "Today"));
        JDatePanelImpl startDatePanel = new JDatePanelImpl(startModel, p);
        startDatePicker = new JDatePickerImpl(startDatePanel, new DateLabelFormatter());
        startDatePicker.setToolTipText("Select the start date for the report");
        startDatePicker.getAccessibleContext().setAccessibleName("Start Date Picker");
        filterPanel.add(startDatePicker);

        JLabel endLabel = new JLabel(getMessage("endDate", "End Date"));
        endLabel.getAccessibleContext().setAccessibleName("End Date Label");
        filterPanel.add(endLabel);
        UtilDateModel endModel = new UtilDateModel();
        JDatePanelImpl endDatePanel = new JDatePanelImpl(endModel, p);
        endDatePicker = new JDatePickerImpl(endDatePanel, new DateLabelFormatter());
        endDatePicker.setToolTipText("Select the end date for the report");
        endDatePicker.getAccessibleContext().setAccessibleName("End Date Picker");
        filterPanel.add(endDatePicker);

        reportTableModel = new VirtualReportTableModel();
        reportTable = new JTable(reportTableModel);
        reportTable.setToolTipText(getMessage("financialSummaryMetrics"));
        reportTable.getAccessibleContext().setAccessibleName("Report Table");
        scrollPane = new JScrollPane(reportTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        chartPanel = new JPanel();
        chartPanel.setToolTipText("Bar chart of financial metrics");
        chartPanel.getAccessibleContext().setAccessibleName("Chart Panel");
        add(new JSplitPane(JSplitPane.VERTICAL_SPLIT, scrollPane, chartPanel), BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton generateSummaryButton = new JButton(getMessage("generateSummary", "Generate Summary"));
        generateSummaryButton.addActionListener(e -> generateCompanySummary());
        generateSummaryButton.setToolTipText("Generate the financial summary report");
        generateSummaryButton.getAccessibleContext().setAccessibleName("Generate Summary Button");
        buttonPanel.add(generateSummaryButton);

        JButton exportExcelButton = new JButton(getMessage("exportExcel", "Export to Excel"));
        exportExcelButton.addActionListener(e -> exportToExcel());
        exportExcelButton.setToolTipText("Export report to Excel");
        exportExcelButton.getAccessibleContext().setAccessibleName("Export Excel Button");
        buttonPanel.add(exportExcelButton);

        JButton exportCsvButton = new JButton(getMessage("exportCsv", "Export to CSV"));
        exportCsvButton.addActionListener(e -> exportToCsv());
        exportCsvButton.setToolTipText("Export report to CSV");
        exportCsvButton.getAccessibleContext().setAccessibleName("Export CSV Button");
        buttonPanel.add(exportCsvButton);

        add(filterPanel, BorderLayout.NORTH);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void generateCompanySummary() {
        CompletableFuture.supplyAsync(() -> {
            try {
                String startDate = ((JTextField) startDatePicker.getJFormattedTextField()).getText();
                String endDate = ((JTextField) endDatePicker.getJFormattedTextField()).getText();
                ErrorHandler.validateDate(startDate, "Start Date");
                ErrorHandler.validateDate(endDate, "End Date");
                return dbService.generateCompanyFinancialSummary(startDate, endDate);
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorGeneratingSummary", "Error generating summary"), this);
                return Collections.emptyMap();
            }
        }).orTimeout(30, TimeUnit.SECONDS).thenAccept(summary -> SwingUtilities.invokeLater(() -> {
            List<Object[]> rows = new ArrayList<>();
            summary.forEach((metric, value) -> rows.add(new Object[]{metric, String.format("%.2f", value)}));
            reportTableModel.setAllRows(rows);
            updateVisibleRows();

            DefaultCategoryDataset dataset = new DefaultCategoryDataset();
            summary.forEach((metric, value) -> dataset.addValue(value, getMessage("financialMetrics", "Financial Metrics"), metric));
            JFreeChart barChart = ChartFactory.createBarChart(
                getMessage("financialSummary", "Financial Summary"),
                getMessage("metric", "Metric"),
                getMessage("value", "Value"),
                dataset
            );
            chartPanel.removeAll();
            chartPanel.add(new ChartPanel(barChart));
            chartPanel.revalidate();
            chartPanel.repaint();
            auditService.logAction(currentUser, "reports", null, "Generated company financial summary", null, null);
        })).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to generate summary", this);
            return null;
        });
    }

    private void exportToExcel() {
        CompletableFuture.runAsync(() -> {
            try (Workbook workbook = new XSSFWorkbook()) {
                Sheet sheet = workbook.createSheet(getMessage("companyFinancialSummary", "Company Financial Summary"));
                Row headerRow = sheet.createRow(0);
                for (int i = 0; i < reportTableModel.getColumnCount(); i++) {
                    headerRow.createCell(i).setCellValue(reportTableModel.getColumnName(i));
                }
                for (int i = 0; i < reportTableModel.getRowCount(); i++) {
                    Row row = sheet.createRow(i + 1);
                    for (int j = 0; j < reportTableModel.getColumnCount(); j++) {
                        Object value = reportTableModel.getValueAt(i, j);
                        row.createCell(j).setCellValue(value != null ? value.toString() : "");
                    }
                }
                try (FileOutputStream fileOut = new FileOutputStream("Company_Financial_Summary.xlsx")) {
                    workbook.write(fileOut);
                }
                auditService.logAction(currentUser, "reports", null, "Exported financial summary to Excel", null, null);
                SwingUtilities.invokeLater(() ->
                    JOptionPane.showMessageDialog(this, getMessage("excelExported", "Excel exported successfully")));
            } catch (IOException e) {
                ErrorHandler.handleException(e, getMessage("errorExportingExcel", "Error exporting Excel"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to export to Excel", this);
            return null;
        });
    }

    private void exportToCsv() {
        CompletableFuture.runAsync(() -> {
            try (FileWriter fileWriter = new FileWriter("Company_Financial_Summary.csv");
                 CSVPrinter csvPrinter = new CSVPrinter(fileWriter, CSVFormat.DEFAULT.withHeader(getMessage("metric", "Metric"), getMessage("value", "Value")))) {
                for (int i = 0; i < reportTableModel.getRowCount(); i++) {
                    csvPrinter.printRecord(
                        reportTableModel.getValueAt(i, 0),
                        reportTableModel.getValueAt(i, 1)
                    );
                }
                csvPrinter.flush();
                auditService.logAction(currentUser, "reports", null, "Exported financial summary to CSV", null, null);
                SwingUtilities.invokeLater(() ->
                    JOptionPane.showMessageDialog(this, getMessage("csvExported", "CSV exported successfully")));
            } catch (IOException e) {
                ErrorHandler.handleException(e, getMessage("errorExportingCsv", "Error exporting CSV"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to export to CSV", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = reportTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        reportTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for AdjustmentsPanel with caching
 */
class VirtualAdjustmentTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final List<Adjustment> visibleRows = new ArrayList<>();
    private final Map<Integer, List<Adjustment>> pageCache = new LinkedHashMap<Integer, List<Adjustment>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<Adjustment>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualAdjustmentTableModel(DatabaseService dbService, int pageSize) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = dbService.getAdjustmentCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<Adjustment> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getAdjustments(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 6; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        Adjustment adj = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return adj.getType();
            case 1: return adj.getDescription();
            case 2: return adj.getAmount();
            case 3: return adj.getAccountFrom() != null ? adj.getAccountFrom() : "N/A";
            case 4: return adj.getAccountTo() != null ? adj.getAccountTo() : "N/A";
            case 5: return adj.getDate();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Type";
            case 1: return "Description";
            case 2: return "Amount";
            case 3: return "From Account";
            case 4: return "To Account";
            case 5: return "Date";
            default: return "";
        }
    }
}

/**
 * Panel for managing settlement adjustments with virtual scrolling and caching.
 */
class AdjustmentsPanel extends JPanel {
    private static final int PAGE_SIZE = 100;
    private JTable adjustmentsTable;
    private VirtualAdjustmentTableModel adjustmentsTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int adjustmentPage = 1;
    private int totalAdjustmentPages = 1;
    private JButton prevButton, nextButton;
    private JLabel adjustmentPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public AdjustmentsPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        adjustmentsTableModel = new VirtualAdjustmentTableModel(dbService, PAGE_SIZE);
        adjustmentsTable = new JTable(adjustmentsTableModel);
        adjustmentsTable.setToolTipText(getMessage("adjustmentsForSettlement"));
        adjustmentsTable.getAccessibleContext().setAccessibleName("Adjustments Table");
        scrollPane = new JScrollPane(adjustmentsTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        JButton addButton = new JButton(getMessage("addAdjustment", "Add Adjustment"));
        addButton.addActionListener(e -> addAdjustment());
        addButton.setToolTipText("Add a new settlement adjustment");
        addButton.getAccessibleContext().setAccessibleName("Add Adjustment Button");
        buttonPanel.add(addButton);

        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (adjustmentPage > 1) {
                adjustmentPage--;
                loadAdjustments();
            }
        });
        prevButton.setToolTipText("Previous page of adjustments");
        prevButton.getAccessibleContext().setAccessibleName("Previous Adjustment Page Button");
        buttonPanel.add(prevButton);

        adjustmentPageLabel = new JLabel("Page " + adjustmentPage + " of " + totalAdjustmentPages);
        adjustmentPageLabel.setToolTipText("Current adjustment page");
        adjustmentPageLabel.getAccessibleContext().setAccessibleName("Adjustment Page Indicator");
        buttonPanel.add(adjustmentPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (adjustmentPage < totalAdjustmentPages) {
                adjustmentPage++;
                loadAdjustments();
            }
        });
        nextButton.setToolTipText("Next page of adjustments");
        nextButton.getAccessibleContext().setAccessibleName("Next Adjustment Page Button");
        buttonPanel.add(nextButton);

        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadAdjustments());
        refreshButton.setToolTipText("Refresh adjustments list");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Adjustments Button");
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadAdjustments();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void addAdjustment() {
        CompletableFuture.runAsync(() -> {
            try {
                JComboBox<String> typeDropdown = new JComboBox<>(new String[]{
                    "BALANCE_TRANSFER", "INVENTORY_VALUATION", "DEFERRED_EXPENSE", "ACCRUED_REVENUE", "TAX_DUE", "OTHER_PAYMENT"
                });
                JTextField descField = new JTextField(20);
                JTextField amountField = new JTextField(10);
                JComboBox<String> fromDropdown = new JComboBox<>();
                dbService.getCustomerCache().forEach((id, name) -> fromDropdown.addItem(id + " - " + name));
                fromDropdown.insertItemAt("N/A", 0);
                JComboBox<String> toDropdown = new JComboBox<>();
                dbService.getCustomerCache().forEach((id, name) -> toDropdown.addItem(id + " - " + name));
                toDropdown.insertItemAt("N/A", 0);
                UtilDateModel model = new UtilDateModel();
                Properties p = new Properties();
                p.put("text.today", getMessage("today", "Today"));
                JDatePickerImpl datePicker = new JDatePickerImpl(new JDatePanelImpl(model, p), new DateLabelFormatter());
                JComboBox<String> currencyDropdown = new JComboBox<>(new String[]{"USD", "IQD", "RMB"});
                JTextField exchangeRateField = new JTextField("1.0", 10);

                JPanel panel = new JPanel(new GridLayout(8, 2));
                panel.add(new JLabel("Adjustment Type:"));
                panel.add(typeDropdown);
                panel.add(new JLabel("Description:"));
                panel.add(descField);
                panel.add(new JLabel("Amount:"));
                panel.add(amountField);
                panel.add(new JLabel("From Account (Customer ID):"));
                panel.add(fromDropdown);
                panel.add(new JLabel("To Account (Customer ID):"));
                panel.add(toDropdown);
                panel.add(new JLabel("Date:"));
                panel.add(datePicker);
                panel.add(new JLabel("Currency:"));
                panel.add(currencyDropdown);
                panel.add(new JLabel("Exchange Rate (to USD):"));
                panel.add(exchangeRateField);

                int result = JOptionPane.showConfirmDialog(this, panel, "Add Settlement Adjustment", JOptionPane.OK_CANCEL_OPTION);
                if (result == JOptionPane.OK_OPTION) {
                    String type = (String) typeDropdown.getSelectedItem();
                    String description = descField.getText();
                    double amount = ErrorHandler.validatePositiveDouble(amountField.getText(), "Amount");
                    Integer accountFrom = "N/A".equals(fromDropdown.getSelectedItem()) ? null : Integer.parseInt(((String) fromDropdown.getSelectedItem()).split(" - ")[0]);
                    Integer accountTo = "N/A".equals(toDropdown.getSelectedItem()) ? null : Integer.parseInt(((String) toDropdown.getSelectedItem()).split(" - ")[0]);
                    String date = ((JTextField) datePicker.getJFormattedTextField()).getText();
                    ErrorHandler.validateDate(date, "Date");
                    String currency = (String) currencyDropdown.getSelectedItem();
                    double exchangeRate = ErrorHandler.validatePositiveDouble(exchangeRateField.getText(), "Exchange Rate");

                    dbService.addAdjustment(type, description, amount, accountFrom, accountTo, date, currency, exchangeRate);
                    auditService.logAction(currentUser, "adjustments", null, "Added adjustment: " + description, null, null);
                    adjustmentsTableModel.invalidateCache();
                    loadAdjustments();
                }
            } catch (ValidationException | DatabaseException e) {
                ErrorHandler.handleException(e, e.getMessage(), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to add adjustment", this);
            return null;
        });
    }

    private void loadAdjustments() {
        CompletableFuture.runAsync(() -> {
            try {
                totalAdjustmentPages = (int) Math.ceil((double) dbService.getAdjustmentCount() / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(adjustmentPage > 1);
                    nextButton.setEnabled(adjustmentPage < totalAdjustmentPages);
                    adjustmentPageLabel.setText("Page " + adjustmentPage + " of " + totalAdjustmentPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingAdjustments", "Error loading adjustments"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load adjustments", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = adjustmentsTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        adjustmentsTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Virtual Table Model for AuditTrailPanel with caching
 */
class VirtualAuditTrailTableModel extends AbstractTableModel {
    private static final int CACHE_SIZE = 10;
    private final DatabaseService dbService;
    private final int pageSize;
    private final List<AuditEntry> visibleRows = new ArrayList<>();
    private final Map<Integer, List<AuditEntry>> pageCache = new LinkedHashMap<Integer, List<AuditEntry>>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, List<AuditEntry>> eldest) {
            return size() > CACHE_SIZE;
        }
    };
    private int totalRowCount = 0;
    private int firstVisibleRow = 0;
    private int visibleRowCount = 0;

    public VirtualAuditTrailTableModel(DatabaseService dbService, int pageSize) {
        this.dbService = dbService;
        this.pageSize = pageSize;
        updateTotalRowCount();
    }

    private void updateTotalRowCount() {
        try {
            totalRowCount = dbService.getAuditLogCount();
        } catch (DatabaseException e) {
            totalRowCount = 0;
        }
    }

    public void invalidateCache() {
        pageCache.clear();
        updateTotalRowCount();
    }

    public void updateVisibleRows(int firstRow, int rowCount) {
        firstVisibleRow = Math.max(0, Math.min(firstRow, totalRowCount - 1));
        visibleRowCount = Math.min(rowCount, totalRowCount - firstVisibleRow);
        visibleRows.clear();

        int startPage = (firstVisibleRow / pageSize) + 1;
        int endPage = ((firstVisibleRow + visibleRowCount - 1) / pageSize) + 1;

        for (int page = startPage; page <= endPage; page++) {
            List<AuditEntry> pageData = pageCache.get(page);
            if (pageData == null) {
                try {
                    pageData = dbService.getAuditLogs(page, pageSize);
                    pageCache.put(page, pageData);
                } catch (DatabaseException e) {
                    pageData = new ArrayList<>();
                }
            }
            int startIndex = (page == startPage) ? firstVisibleRow % pageSize : 0;
            int endIndex = (page == endPage) ? (firstVisibleRow + visibleRowCount - 1) % pageSize + 1 : pageData.size();
            visibleRows.addAll(pageData.subList(startIndex, Math.min(endIndex, pageData.size())));
        }

        fireTableDataChanged();
    }

    @Override
    public int getRowCount() { return totalRowCount; }
    @Override
    public int getColumnCount() { return 6; }
    @Override
    public Object getValueAt(int rowIndex, int columnIndex) {
        if (rowIndex < firstVisibleRow || rowIndex >= firstVisibleRow + visibleRowCount) return "";
        AuditEntry entry = visibleRows.get(rowIndex - firstVisibleRow);
        switch (columnIndex) {
            case 0: return entry.getTimestamp();
            case 1: return entry.getUser();
            case 2: return entry.getTableName();
            case 3: return entry.getRecordId();
            case 4: return entry.getAction();
            case 5: return entry.getOldValue() != null ? entry.getOldValue() + " -> " + entry.getNewValue() : entry.getNewValue();
            default: return "";
        }
    }

    @Override
    public String getColumnName(int column) {
        switch (column) {
            case 0: return "Timestamp";
            case 1: return "User";
            case 2: return "Table";
            case 3: return "Record ID";
            case 4: return "Action";
            case 5: return "Details";
            default: return "";
        }
    }
}

/**
 * Panel for viewing audit trail with virtual scrolling and caching.
 */
class AuditTrailPanel extends JPanel {
    private static final int PAGE_SIZE = 100;
    private JTable auditTable;
    private VirtualAuditTrailTableModel auditTableModel;
    private ResourceBundle messages;
    private final DatabaseService dbService;
    private final AuditService auditService;
    private int auditPage = 1;
    private int totalAuditPages = 1;
    private JButton prevButton, nextButton;
    private JLabel auditPageLabel;
    private JScrollPane scrollPane;
    private String currentUser = "User1";

    public AuditTrailPanel(ResourceBundle messages, DatabaseService dbService, AuditService auditService) {
        this.messages = messages;
        this.dbService = dbService;
        this.auditService = auditService;
        initializeUI();
    }

    private void initializeUI() {
        setLayout(new BorderLayout());

        auditTableModel = new VirtualAuditTrailTableModel(dbService, PAGE_SIZE);
        auditTable = new JTable(auditTableModel);
        auditTable.setToolTipText(getMessage("auditTrail"));
        auditTable.getAccessibleContext().setAccessibleName("Audit Trail Table");
        scrollPane = new JScrollPane(auditTable);
        scrollPane.getViewport().addChangeListener(e -> updateVisibleRows());
        add(scrollPane, BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel(new FlowLayout());
        prevButton = new JButton(getMessage("prev", "Previous"));
        prevButton.addActionListener(e -> {
            if (auditPage > 1) {
                auditPage--;
                loadAuditTrail();
            }
        });
        prevButton.setToolTipText("Previous page of audit logs");
        prevButton.getAccessibleContext().setAccessibleName("Previous Audit Page Button");
        buttonPanel.add(prevButton);

        auditPageLabel = new JLabel("Page " + auditPage + " of " + totalAuditPages);
        auditPageLabel.setToolTipText("Current audit page");
        auditPageLabel.getAccessibleContext().setAccessibleName("Audit Page Indicator");
        buttonPanel.add(auditPageLabel);

        nextButton = new JButton(getMessage("next", "Next"));
        nextButton.addActionListener(e -> {
            if (auditPage < totalAuditPages) {
                auditPage++;
                loadAuditTrail();
            }
        });
        nextButton.setToolTipText("Next page of audit logs");
        nextButton.getAccessibleContext().setAccessibleName("Next Audit Page Button");
        buttonPanel.add(nextButton);

        JButton refreshButton = new JButton(getMessage("refresh", "Refresh"));
        refreshButton.addActionListener(e -> loadAuditTrail());
        refreshButton.setToolTipText("Refresh audit trail");
        refreshButton.getAccessibleContext().setAccessibleName("Refresh Audit Button");
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);

        loadAuditTrail();
    }

    private String getMessage(String key) {
        try {
            return messages.getString(key);
        } catch (MissingResourceException e) {
            return key;
        }
    }

    private void loadAuditTrail() {
        CompletableFuture.runAsync(() -> {
            try {
                totalAuditPages = (int) Math.ceil((double) dbService.getAuditLogCount() / PAGE_SIZE);
                SwingUtilities.invokeLater(() -> {
                    updateVisibleRows();
                    prevButton.setEnabled(auditPage > 1);
                    nextButton.setEnabled(auditPage < totalAuditPages);
                    auditPageLabel.setText("Page " + auditPage + " of " + totalAuditPages);
                });
            } catch (DatabaseException e) {
                ErrorHandler.handleException(e, getMessage("errorLoadingAuditTrail", "Error loading audit trail"), this);
            }
        }).orTimeout(30, TimeUnit.SECONDS).exceptionally(throwable -> {
            ErrorHandler.handleException(throwable, "Failed to load audit trail", this);
            return null;
        });
    }

    private void updateVisibleRows() {
        JViewport viewport = scrollPane.getViewport();
        int rowHeight = auditTable.getRowHeight();
        int visibleHeight = viewport.getHeight();
        int firstRow = viewport.getViewPosition().y / rowHeight;
        int visibleRowCount = (int) Math.ceil((double) visibleHeight / rowHeight) + 1;
        auditTableModel.updateVisibleRows(firstRow, visibleRowCount);
    }
}

/**
 * Utility class for error handling and data validation.
 */
class ErrorHandler {
    private static final Logger LOGGER = Logger.getLogger(ErrorHandler.class.getName());
    private static final Pattern DATE_PATTERN = Pattern.compile("\\d{4}-\\d{2}-\\d{2}");
    private static final Pattern STRING_PATTERN = Pattern.compile("[a-zA-Z0-9\\s_-]+");

    public static void handleException(Throwable e, String userMessage, Component parent) {
        LOGGER.severe(userMessage + ": " + e.getMessage());
        SwingUtilities.invokeLater(() ->
            JOptionPane.showMessageDialog(parent != null ? parent : JOptionPane.getRootFrame(),
                userMessage, "Error", JOptionPane.ERROR_MESSAGE));
    }

    public static void validateRequiredField(String input, String fieldName) throws ValidationException {
        if (input == null || input.trim().isEmpty()) {
            throw new ValidationException(fieldName + " is required");
        }
    }

    public static int validatePositiveInteger(String input, String fieldName) throws ValidationException {
        validateRequiredField(input, fieldName);
        try {
            int value = Integer.parseInt(input);
            if (value <= 0) throw new ValidationException(fieldName + " must be positive");
            return value;
        } catch (NumberFormatException e) {
            throw new ValidationException(fieldName + " must be a number");
        }
    }

    public static double validatePositiveDouble(String input, String fieldName) throws ValidationException {
        validateRequiredField(input, fieldName);
        try {
            double value = Double.parseDouble(input);
            if (value <= 0) throw new ValidationException(fieldName + " must be positive");
            return value;
        } catch (NumberFormatException e) {
            throw new ValidationException(fieldName + " must be a number");
        }
    }

    public static boolean validateStringSafe(String input, String fieldName) {
        try {
            validateString(input, fieldName);
            return true;
        } catch (ValidationException e) {
            ErrorHandler.handleException(e, e.getMessage(), null);
            return false;
        }
    }

    public static void validateString(String input, String fieldName) throws ValidationException {
        validateRequiredField(input, fieldName);
        if (!STRING_PATTERN.matcher(input).matches()) {
            throw new ValidationException(fieldName + " contains invalid characters");
        }
    }

    public static void validateDate(String input, String fieldName) throws ValidationException {
        validateRequiredField(input, fieldName);
        if (!DATE_PATTERN.matcher(input).matches()) {
            throw new ValidationException(fieldName + " must be in yyyy-MM-dd format");
        }
        try {
            new SimpleDateFormat("yyyy-MM-dd").parse(input);
        } catch (ParseException e) {
            throw new ValidationException(fieldName + " is an invalid date");
        }
    }
}

/**
 * Custom exception for database errors.
 */
class DatabaseException extends Exception {
    public DatabaseException(String message, Throwable cause) {
        super(message, cause);
    }
}

/**
 * Custom exception for validation errors.
 */
class ValidationException extends Exception {
    public ValidationException(String message) {
        super(message);
    }
}

/**
 * Service class for database operations with LRU caching and history tracking.
 */
class DatabaseService {
    private static final int MAX_POOL_SIZE = 100;
    private static final int MIN_IDLE = 10;
    private static final int CACHE_SIZE = 100;
    private static final int BATCH_SIZE = 1000;
    private static final Pattern DB_NAME_PATTERN = Pattern.compile("[a-zA-Z0-9_]+");
    private HikariDataSource dataSource;
    private final Map<Integer, String> customerCache = Collections.synchronizedMap(new LinkedHashMap<Integer, String>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
            return size() > CACHE_SIZE;
        }
    });
    private final Map<Integer, Product> productCache = Collections.synchronizedMap(new LinkedHashMap<Integer, Product>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, Product> eldest) {
            return size() > CACHE_SIZE;
        }
    });
    private final Map<Integer, String> warehouseCache = Collections.synchronizedMap(new LinkedHashMap<Integer, String>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
            return size() > CACHE_SIZE;
        }
    });
    private final Map<Integer, String> supplierCache = Collections.synchronizedMap(new LinkedHashMap<Integer, String>(CACHE_SIZE, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry<Integer, String> eldest) {
            return size() > CACHE_SIZE;
        }
    });

    public DatabaseService() {}

    public void setConnectionDetails(String url, String username, String password) throws DatabaseException {
        try {
            HikariConfig config = new HikariConfig();
            config.setJdbcUrl(url);
            config.setUsername(username);
            config.setPassword(password);
            config.setMaximumPoolSize(MAX_POOL_SIZE);
            config.setMinimumIdle(MIN_IDLE);
            config.setConnectionTimeout(30000);
            config.setIdleTimeout(600000);
            config.addDataSourceProperty("cachePrepStmts", "true");
            config.addDataSourceProperty("prepStmtCacheSize", "250");
            config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
            this.dataSource = new HikariDataSource(config);
            initializeDatabase();
        } catch (Exception e) {
            throw new DatabaseException("Failed to set connection details", e);
        }
    }

    public void createNewDatabase(String dbName) throws DatabaseException {
        if (!DB_NAME_PATTERN.matcher(dbName).matches()) {
            throw new DatabaseException("Invalid database name: " + dbName, null);
        }
        String baseUrl = dataSource.getJdbcUrl().substring(0, dataSource.getJdbcUrl().lastIndexOf("/") + 1);
        try (Connection conn = DriverManager.getConnection(baseUrl, dataSource.getUsername(), dataSource.getPassword());
             PreparedStatement stmt = conn.prepareStatement("CREATE DATABASE IF NOT EXISTS " + dbName)) {
            stmt.executeUpdate();
            setConnectionDetails(baseUrl + dbName, dataSource.getUsername(), dataSource.getPassword());
        } catch (SQLException e) {
            throw new DatabaseException("Failed to create database: " + dbName, e);
        }
    }

    public void initializeDatabase() throws DatabaseException {
        try (Connection connection = dataSource.getConnection();
             Statement statement = connection.createStatement()) {
            statement.execute("CREATE TABLE IF NOT EXISTS Customers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, contact VARCHAR(50), email VARCHAR(100), address VARCHAR(255), INDEX idx_customers_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Suppliers (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, contact VARCHAR(50), email VARCHAR(100), address VARCHAR(255), INDEX idx_suppliers_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Warehouses (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, INDEX idx_warehouses_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, sellingPrice DOUBLE NOT NULL, costPrice DOUBLE NOT NULL, unit VARCHAR(50) NOT NULL, INDEX idx_products_name (name))");
            statement.execute("CREATE TABLE IF NOT EXISTS Invoices (id VARCHAR(50) PRIMARY KEY, customerId INT, type ENUM('SALE', 'PURCHASE', 'IMPORT', 'SALE_RETURN', 'PURCHASE_RETURN') NOT NULL, date DATE NOT NULL, totalAmount DOUBLE NOT NULL, currency VARCHAR(50) NOT NULL, paymentCurrency VARCHAR(50) NOT NULL, paymentInstructions VARCHAR(255), deliveryStatus VARCHAR(255), notes TEXT, exchangeRate DOUBLE NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_invoices_type_date (type, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceLineItems (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, unit VARCHAR(50) NOT NULL, unitPrice DOUBLE NOT NULL, totalPrice DOUBLE NOT NULL, unitCost DOUBLE NOT NULL, totalCost DOUBLE NOT NULL, currency VARCHAR(3) NOT NULL DEFAULT 'USD', FOREIGN KEY (invoiceId) REFERENCES Invoices(id), FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id), INDEX idx_lineitems_invoice_product (invoiceId, productId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Inventory (productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, PRIMARY KEY (productId, warehouseId), FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS InventoryTransactions (id INT AUTO_INCREMENT PRIMARY KEY, productId INT NOT NULL, warehouseId INT NOT NULL, quantity INT NOT NULL, type ENUM('IN', 'OUT') NOT NULL, date DATETIME NOT NULL, cost DOUBLE NOT NULL, FOREIGN KEY (productId) REFERENCES Products(id), FOREIGN KEY (warehouseId) REFERENCES Warehouses(id), INDEX idx_invtrans_product_date (productId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS Attachments (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, fileName VARCHAR(255) NOT NULL, fileSize BIGINT NOT NULL, uploadDate DATETIME NOT NULL, FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_attachments_invoice (invoiceId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Payments (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, invoiceId VARCHAR(50), amount DOUBLE NOT NULL, paymentDate DATETIME NOT NULL, currency VARCHAR(3) NOT NULL DEFAULT 'USD', exchangeRate DOUBLE NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_payments_customer_date (customerId, paymentDate))");
            statement.execute("CREATE TABLE IF NOT EXISTS CashTransactions (id INT AUTO_INCREMENT PRIMARY KEY, description VARCHAR(255) NOT NULL, amount DOUBLE NOT NULL, type ENUM('IN', 'OUT') NOT NULL, category VARCHAR(50) NOT NULL DEFAULT 'Other', date DATETIME NOT NULL, budgetId INT, INDEX idx_cash_date_category (date, category), FOREIGN KEY (budgetId) REFERENCES Budgets(id))");
            statement.execute("CREATE TABLE IF NOT EXISTS CustomerDebits (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, amount DOUBLE NOT NULL, description VARCHAR(255), date DATETIME NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_debits_customer_date (customerId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS CustomerCredits (id INT AUTO_INCREMENT PRIMARY KEY, customerId INT NOT NULL, amount DOUBLE NOT NULL, description VARCHAR(255), date DATETIME NOT NULL, FOREIGN KEY (customerId) REFERENCES Customers(id), INDEX idx_credits_customer_date (customerId, date))");
            statement.execute("CREATE TABLE IF NOT EXISTS AuditLog (id INT AUTO_INCREMENT PRIMARY KEY, user VARCHAR(50) NOT NULL, tableName VARCHAR(50), recordId VARCHAR(50), action VARCHAR(255) NOT NULL, oldValue TEXT, newValue TEXT, timestamp DATETIME NOT NULL, INDEX idx_audit_timestamp (timestamp))");
            statement.execute("CREATE TABLE IF NOT EXISTS InvoiceHistory (id INT AUTO_INCREMENT PRIMARY KEY, invoiceId VARCHAR(50) NOT NULL, changeDescription TEXT NOT NULL, changedBy VARCHAR(50) NOT NULL, changeDate DATETIME NOT NULL, FOREIGN KEY (invoiceId) REFERENCES Invoices(id), INDEX idx_history_invoice (invoiceId))");
            statement.execute("CREATE TABLE IF NOT EXISTS Adjustments (" +
                "id INT AUTO_INCREMENT PRIMARY KEY, " +
                "type ENUM('BALANCE_TRANSFER', 'INVENTORY_VALUATION', 'DEFERRED_EXPENSE', 'ACCRUED_REVENUE', 'TAX_DUE', 'OTHER_PAYMENT') NOT NULL, " +
                "description VARCHAR(255) NOT NULL, " +
                "amount DOUBLE NOT NULL, " +
                "accountFrom INT, " +
                "accountTo INT, " +
                "date DATETIME NOT NULL, " +
                "currency VARCHAR(3) NOT NULL DEFAULT 'USD', " +
                "exchangeRate DOUBLE NOT NULL DEFAULT 1.0, " +
                "FOREIGN KEY (accountFrom) REFERENCES Customers(id), " +
                "FOREIGN KEY (accountTo) REFERENCES Customers(id), " +
                "INDEX idx_adjustments_type_date (type, date)" +
            ")");
            statement.execute("CREATE TABLE IF NOT EXISTS RecurringInvoices (" +
                "id INT AUTO_INCREMENT PRIMARY KEY, " +
                "invoiceId VARCHAR(50) NOT NULL, " +
                "frequency INT NOT NULL, " +
                "nextDate DATE NOT NULL, " +
                "endDate DATE NOT NULL, " +
                "lastGenerated DATE, " +
                "FOREIGN KEY (invoiceId) REFERENCES Invoices(id), " +
                "INDEX idx_recurring_nextdate (nextDate)" +
            ")");
            statement.execute("CREATE TABLE IF NOT EXISTS Budgets (" +
                "id INT AUTO_INCREMENT PRIMARY KEY, " +
                "category VARCHAR(50) NOT NULL, " +
                "amount DOUBLE NOT NULL, " +
                "period VARCHAR(20) NOT NULL DEFAULT 'Monthly', " +
                "INDEX idx_budgets_category (category)" +
            ")");
        } catch (SQLException e) {
            throw new DatabaseException("Failed to initialize database", e);
        }
    }

    public void loadCustomers(JComboBox<String> customerDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Customers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            customerCache.clear();
            while (rs.next()) {
                customerCache.put(rs.getInt("id"), rs.getString("name"));
            }
            customerDropdown.removeAllItems();
            customerCache.forEach((id, name) -> customerDropdown.addItem(id + " - " + name));
        } catch (SQLException e) {
            throw new DatabaseException("Failed to load customers", e);
        }
    }

    public List<Contact> getCustomers(int pageNumber, int pageSize) throws DatabaseException {
        List<Contact> customers = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name, contact, email, address FROM Customers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                customers.add(new Contact(rs.getInt("id"), rs.getString("name"), rs.getString("contact"), rs.getString("email"), rs.getString("address")));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get customers", e);
        }
        return customers;
    }

    public int getCustomerCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Customers")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get customer count", e);
        }
    }

    public void loadSuppliers(JComboBox<String> supplierDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Suppliers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            supplierCache.clear();
            while (rs.next()) {
                supplierCache.put(rs.getInt("id"), rs.getString("name"));
            }
            supplierDropdown.removeAllItems();
            supplierCache.forEach((id, name) -> supplierDropdown.addItem(id + " - " + name));
        } catch (SQLException e) {
            throw new DatabaseException("Failed to load suppliers", e);
        }
    }

    public List<Contact> getSuppliers(int pageNumber, int pageSize) throws DatabaseException {
        List<Contact> suppliers = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name, contact, email, address FROM Suppliers ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                suppliers.add(new Contact(rs.getInt("id"), rs.getString("name"), rs.getString("contact"), rs.getString("email"), rs.getString("address")));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get suppliers", e);
        }
        return suppliers;
    }

    public int getSupplierCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Suppliers")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get supplier count", e);
        }
    }

    public void loadWarehouses(JComboBox<String> warehouseDropdown, int pageNumber, int pageSize) throws DatabaseException {
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id, name FROM Warehouses ORDER BY name LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            warehouseCache.clear();
            while (rs.next()) {
                warehouseCache.put(rs.getInt("id"), rs.getString("name"));
            }
            warehouseDropdown.removeAllItems();
            warehouseCache.forEach((id, name) -> warehouseDropdown.addItem(id + " - " + name));
        } catch (SQLException e) {
            throw new DatabaseException("Failed to load warehouses", e);
        }
    }

    public int getWarehouseCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Warehouses")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get warehouse count", e);
        }
    }

    public Map<Integer, String> getCustomerCache() { return customerCache; }
    public Map<Integer, String> getSupplierCache() { return supplierCache; }
    public Map<Integer, String> getWarehouseCache() { return warehouseCache; }

    public void addCustomer(String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Customers (name, contact, email, address) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) customerCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add customer: " + name, e);
        }
    }

    public void updateCustomer(int id, String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("UPDATE Customers SET name = ?, contact = ?, email = ?, address = ? WHERE id = ?")) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.setInt(5, id);
            stmt.executeUpdate();
            customerCache.put(id, name);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to update customer: " + id, e);
        }
    }

    public void addSupplier(String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Suppliers (name, contact, email, address) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) supplierCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add supplier: " + name, e);
        }
    }

    public void updateSupplier(int id, String name, String contact, String email, String address) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("UPDATE Suppliers SET name = ?, contact = ?, email = ?, address = ? WHERE id = ?")) {
            stmt.setString(1, name);
            stmt.setString(2, contact);
            stmt.setString(3, email);
            stmt.setString(4, address);
            stmt.setInt(5, id);
            stmt.executeUpdate();
            supplierCache.put(id, name);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to update supplier: " + id, e);
        }
    }

    public void addWarehouse(String name) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Warehouses (name) VALUES (?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) warehouseCache.put(rs.getInt(1), name);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add warehouse: " + name, e);
        }
    }

    public void addProduct(String name, double sellingPrice, double costPrice, String unit) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("INSERT INTO Products (name, sellingPrice, costPrice, unit) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, name);
            stmt.setDouble(2, sellingPrice);
            stmt.setDouble(3, costPrice);
            stmt.setString(4, unit);
            stmt.executeUpdate();
            ResultSet rs = stmt.getGeneratedKeys();
            if (rs.next()) productCache.put(rs.getInt(1), new Product(name, sellingPrice, costPrice, unit));
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add product: " + name, e);
        }
    }

    public String generateInvoiceId(String prefix) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT id FROM Invoices WHERE id LIKE ? ORDER BY CAST(SUBSTRING(id, ?) AS UNSIGNED) DESC LIMIT 1")) {
            stmt.setString(1, prefix + "-%");
            stmt.setInt(2, prefix.length() + 2);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                String lastId = rs.getString("id");
                int number = Integer.parseInt(lastId.substring(prefix.length() + 1)) + 1;
                return String.format("%s-%05d", prefix, number);
            }
            return String.format("%s-00001", prefix);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to generate invoice ID", e);
        }
    }

    public InvoiceLineItem addLineItem(int productId, int warehouseId, int quantity, String unit, String currency, boolean isPurchase) throws DatabaseException {
        Product product = productCache.computeIfAbsent(productId, id -> {
            try (Connection conn = dataSource.getConnection();
                 PreparedStatement stmt = conn.prepareStatement("SELECT name, sellingPrice, costPrice, unit FROM Products WHERE id = ?")) {
                stmt.setInt(1, id);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) return new Product(rs.getString("name"), rs.getDouble("sellingPrice"), rs.getDouble("costPrice"), rs.getString("unit"));
                return null;
            } catch (SQLException e) {
                throw new RuntimeException("Failed to fetch product: " + id, e);
            }
        });
        if (product == null) throw new DatabaseException("Product not found: " + productId, null);

        double unitPrice = isPurchase ? product.getCostPrice() : product.getSellingPrice();
        double totalPrice = unitPrice * quantity;
        double unitCost = product.getCostPrice();
        double totalCost = unitCost * quantity;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceLineItems (productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, currency) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                 Statement.RETURN_GENERATED_KEYS)) {
            stmt.setInt(1, productId);
            stmt.setInt(2, warehouseId);
            stmt.setInt(3, quantity);
            stmt.setString(4, unit);
            stmt.setDouble(5, unitPrice);
            stmt.setDouble(6, totalPrice);
            stmt.setDouble(7, unitCost);
            stmt.setDouble(8, totalCost);
            stmt.setString(9, currency);
            stmt.executeUpdate();

            ResultSet keys = stmt.getGeneratedKeys();
            if (keys.next()) return new InvoiceLineItem(keys.getInt(1), productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, currency);
            return null;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add line item for product: " + productId, e);
        }
    }

    public void saveInvoice(Integer customerId, String invoiceType, String date, double totalAmount, String currency,
                            List<InvoiceLineItem> lineItems, String invoiceId, String paymentCurrency,
                            String paymentInstructions, String deliveryStatus, String notes, double exchangeRate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            String finalInvoiceId = invoiceId != null ? invoiceId : generateInvoiceId(invoiceType.substring(0, 3).toUpperCase());
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Invoices (id, customerId, type, date, totalAmount, currency, paymentCurrency, paymentInstructions, deliveryStatus, notes, exchangeRate) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                stmt.setString(1, finalInvoiceId);
                stmt.setObject(2, customerId, Types.INTEGER);
                stmt.setString(3, invoiceType.toUpperCase());
                stmt.setString(4, date);
                stmt.setDouble(5, totalAmount);
                stmt.setString(6, currency);
                stmt.setString(7, paymentCurrency);
                stmt.setString(8, paymentInstructions);
                stmt.setString(9, deliveryStatus);
                stmt.setString(10, notes);
                stmt.setDouble(11, exchangeRate);
                stmt.executeUpdate();
            }

            List<List<InvoiceLineItem>> batches = partition(lineItems, BATCH_SIZE);
            for (List<InvoiceLineItem> batch : batches) {
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, currency) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                    for (InvoiceLineItem item : batch) {
                        stmt.setString(1, finalInvoiceId);
                        stmt.setInt(2, item.getProductId());
                        stmt.setInt(3, item.getWarehouseId());
                        stmt.setInt(4, item.getQuantity());
                        stmt.setString(5, item.getUnit());
                        stmt.setDouble(6, item.getUnitPrice());
                        stmt.setDouble(7, item.getTotalPrice());
                        stmt.setDouble(8, item.getUnitCost());
                        stmt.setDouble(9, item.getTotalCost());
                        stmt.setString(10, item.getCurrency());
                        stmt.addBatch();
                    }
                    stmt.executeBatch();
                }
            }

            updateInvoiceTransactions(conn, finalInvoiceId, customerId, totalAmount, invoiceType, lineItems);
            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DatabaseException("Rollback failed after save invoice error", rollbackEx);
            }
            throw new DatabaseException("Failed to save invoice", e);
        }
    }

    public void updateInvoice(String invoiceId, Integer customerId, String invoiceType, String date, double totalAmount, String currency,
                              List<InvoiceLineItem> lineItems, String paymentCurrency, String paymentInstructions, String deliveryStatus, String notes, double exchangeRate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            InvoiceDetails original = loadInvoiceDetails(invoiceId);
            if (original == null) throw new DatabaseException("Invoice not found: " + invoiceId, null);

            try (PreparedStatement stmt = conn.prepareStatement(
                "UPDATE Invoices SET customerId = ?, type = ?, date = ?, totalAmount = ?, currency = ?, paymentCurrency = ?, paymentInstructions = ?, deliveryStatus = ?, notes = ?, exchangeRate = ? WHERE id = ?")) {
                stmt.setObject(1, customerId, Types.INTEGER);
                stmt.setString(2, invoiceType.toUpperCase());
                stmt.setString(3, date);
                stmt.setDouble(4, totalAmount);
                stmt.setString(5, currency);
                stmt.setString(6, paymentCurrency);
                stmt.setString(7, paymentInstructions);
                stmt.setString(8, deliveryStatus);
                stmt.setString(9, notes);
                stmt.setDouble(10, exchangeRate);
                stmt.setString(11, invoiceId);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM InvoiceLineItems WHERE invoiceId = ?")) {
                stmt.setString(1, invoiceId);
                stmt.executeUpdate();
            }

            List<List<InvoiceLineItem>> batches = partition(lineItems, BATCH_SIZE);
            for (List<InvoiceLineItem> batch : batches) {
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, currency) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                    for (InvoiceLineItem item : batch) {
                        stmt.setString(1, invoiceId);
                        stmt.setInt(2, item.getProductId());
                        stmt.setInt(3, item.getWarehouseId());
                        stmt.setInt(4, item.getQuantity());
                        stmt.setString(5, item.getUnit());
                        stmt.setDouble(6, item.getUnitPrice());
                        stmt.setDouble(7, item.getTotalPrice());
                        stmt.setDouble(8, item.getUnitCost());
                        stmt.setDouble(9, item.getTotalCost());
                        stmt.setString(10, item.getCurrency());
                        stmt.addBatch();
                    }
                    stmt.executeBatch();
                }
            }

            StringBuilder changes = new StringBuilder();
            if (!Objects.equals(original.getInvoiceType(), invoiceType)) changes.append("Type changed from ").append(original.getInvoiceType()).append(" to ").append(invoiceType).append("; ");
            if (!Objects.equals(original.getCustomerName(), customerId != null ? customerCache.get(customerId) : null)) changes.append("Customer changed from ").append(original.getCustomerName()).append(" to ").append(customerId != null ? customerCache.get(customerId) : "N/A").append("; ");
            if (!Objects.equals(original.getDate(), date)) changes.append("Date changed from ").append(original.getDate()).append(" to ").append(date).append("; ");
            if (original.getTotalAmount() != totalAmount) changes.append("Total Amount (USD) changed from ").append(original.getTotalAmount()).append(" to ").append(totalAmount).append("; ");
            if (changes.length() > 0) logInvoiceChange(invoiceId, changes.toString(), "User1");

            updateInvoiceTransactions(conn, invoiceId, customerId, totalAmount, invoiceType, lineItems);

            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DatabaseException("Rollback failed after update invoice error", rollbackEx);
            }
            throw new DatabaseException("Failed to update invoice: " + invoiceId, e);
        }
    }

    private void updateInvoiceTransactions(Connection conn, String invoiceId, Integer customerId, double totalAmount, String invoiceType, List<InvoiceLineItem> lineItems) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CustomerDebits WHERE description = ?")) {
            stmt.setString(1, "Invoice #" + invoiceId);
            stmt.executeUpdate();
        }
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CustomerCredits WHERE description = ?")) {
            stmt.setString(1, "Return Invoice #" + invoiceId);
            stmt.executeUpdate();
        }
        try (PreparedStatement stmt = conn.prepareStatement("DELETE FROM CashTransactions WHERE description LIKE ?")) {
            stmt.setString(1, "%Invoice #" + invoiceId + "%");
            stmt.executeUpdate();
        }

        switch (invoiceType.toUpperCase()) {
            case "SALE":
                if (customerId != null) {
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                        stmt.setInt(1, customerId);
                        stmt.setDouble(2, totalAmount);
                        stmt.setString(3, "Invoice #" + invoiceId);
                        stmt.executeUpdate();
                    }
                }
                double totalCostSale = lineItems.stream().mapToDouble(InvoiceLineItem::getTotalCost).sum();
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Sales', NOW()), (?, ?, 'OUT', 'COGS', NOW())")) {
                    stmt.setString(1, "Invoice #" + invoiceId + " Sales");
                    stmt.setDouble(2, totalAmount);
                    stmt.setString(3, "Invoice #" + invoiceId + " COGS");
                    stmt.setDouble(4, totalCostSale);
                    stmt.executeBatch();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "OUT");
                break;

            case "PURCHASE":
            case "IMPORT":
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, NOW())")) {
                    stmt.setString(1, invoiceType + " Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.setString(3, invoiceType.equals("PURCHASE") ? "Purchases" : "Imports");
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "IN");
                break;

            case "SALE_RETURN":
                if (customerId != null) {
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                        stmt.setInt(1, customerId);
                        stmt.setDouble(2, totalAmount);
                        stmt.setString(3, "Return Invoice #" + invoiceId);
                        stmt.executeUpdate();
                    }
                }
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', 'Sales Returns', NOW())")) {
                    stmt.setString(1, "Return Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "IN");
                break;

            case "PURCHASE_RETURN":
                try (PreparedStatement stmt = conn.prepareStatement(
                    "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Purchase Returns', NOW())")) {
                    stmt.setString(1, "Return Invoice #" + invoiceId);
                    stmt.setDouble(2, totalAmount);
                    stmt.executeUpdate();
                }
                for (InvoiceLineItem item : lineItems) updateInventory(conn, Collections.singletonList(item), item.getWarehouseId(), "OUT");
                break;
        }
    }

    private void updateInventory(Connection conn, List<InvoiceLineItem> lineItems, int warehouseId, String type) throws SQLException {
        try (PreparedStatement stmt = conn.prepareStatement(
            "INSERT INTO InventoryTransactions (productId, warehouseId, quantity, type, date, cost) VALUES (?, ?, ?, ?, NOW(), ?)")) {
            try (PreparedStatement updateStmt = conn.prepareStatement(
                type.equals("IN") ?
                "INSERT INTO Inventory (productId, warehouseId, quantity) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE quantity = quantity + ?" :
                "UPDATE Inventory SET quantity = quantity - ? WHERE productId = ? AND warehouseId = ?")) {
                for (InvoiceLineItem item : lineItems) {
                    stmt.setInt(1, item.getProductId());
                    stmt.setInt(2, warehouseId);
                    stmt.setInt(3, item.getQuantity());
                    stmt.setString(4, type);
                    stmt.setDouble(5, item.getTotalCost());
                    stmt.addBatch();

                    updateStmt.setInt(1, item.getQuantity());
                    updateStmt.setInt(2, item.getProductId());
                    updateStmt.setInt(3, warehouseId);
                    if (type.equals("IN")) updateStmt.setInt(4, item.getQuantity());
                    updateStmt.addBatch();
                }
                stmt.executeBatch();
                updateStmt.executeBatch();
            }
        }
    }

    public InvoiceDetails loadInvoiceDetails(String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.*, COALESCE(c.name, s.name) AS customerName, " +
                 "COALESCE(SUM(d.amount), 0) - COALESCE(SUM(cr.amount), 0) AS debitCredit " +
                 "FROM Invoices i " +
                 "LEFT JOIN Customers c ON i.customerId = c.id " +
                 "LEFT JOIN Suppliers s ON i.customerId = s.id " +
                 "LEFT JOIN CustomerDebits d ON i.customerId = d.customerId " +
                 "LEFT JOIN CustomerCredits cr ON i.customerId = cr.customerId " +
                 "WHERE i.id = ? " +
                 "GROUP BY i.id, c.name, s.name")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                List<InvoiceLineItem> lineItems = loadLineItems(invoiceId);
                double exchangeRate = rs.getDouble("exchangeRate");
                double usdTotal = 0.0, localTotal = 0.0;
                for (InvoiceLineItem item : lineItems) {
                    if ("USD".equals(item.getCurrency())) {
                        usdTotal += item.getTotalPrice();
                        localTotal += item.getTotalPrice() * exchangeRate;
                    } else {
                        localTotal += item.getTotalPrice();
                        usdTotal += item.getTotalPrice() / exchangeRate;
                    }
                }
                double totalDebit = rs.getDouble("debitCredit");
                double lastDebit = totalDebit;
                return new InvoiceDetails(
                    rs.getString("id"),
                    rs.getString("type"),
                    rs.getString("customerName"),
                    null,
                    rs.getString("date"),
                    usdTotal,
                    totalDebit,
                    lastDebit,
                    rs.getString("currency"),
                    rs.getString("deliveryStatus"),
                    rs.getString("paymentInstructions"),
                    rs.getString("notes"),
                    lineItems,
                    usdTotal,
                    localTotal
                );
            }
            return null;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to load invoice details: " + invoiceId, e);
        }
    }

    private List<InvoiceLineItem> loadLineItems(String invoiceId) throws DatabaseException {
        List<InvoiceLineItem> lineItems = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT * FROM InvoiceLineItems WHERE invoiceId = ?")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                lineItems.add(new InvoiceLineItem(
                    rs.getInt("id"),
                    rs.getInt("productId"),
                    rs.getInt("warehouseId"),
                    rs.getInt("quantity"),
                    rs.getString("unit"),
                    rs.getDouble("unitPrice"),
                    rs.getDouble("totalPrice"),
                    rs.getDouble("unitCost"),
                    rs.getDouble("totalCost"),
                    rs.getString("currency")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to load line items for invoice: " + invoiceId, e);
        }
        return lineItems;
    }

    public void saveRecurringInvoice(String invoiceId, int frequency, String nextDate, String endDate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO RecurringInvoices (invoiceId, frequency, nextDate, endDate) VALUES (?, ?, ?, ?)")) {
            stmt.setString(1, invoiceId);
            stmt.setInt(2, frequency);
            stmt.setString(3, nextDate);
            stmt.setString(4, endDate);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DatabaseException("Failed to save recurring invoice: " + invoiceId, e);
        }
    }

    public List<RecurringInvoice> getRecurringInvoices(int pageNumber, int pageSize) throws DatabaseException {
        List<RecurringInvoice> invoices = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM RecurringInvoices ORDER BY nextDate LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                invoices.add(new RecurringInvoice(
                    rs.getInt("id"),
                    rs.getString("invoiceId"),
                    rs.getInt("frequency"),
                    rs.getString("nextDate"),
                    rs.getString("endDate"),
                    rs.getString("lastGenerated")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get recurring invoices", e);
        }
        return invoices;
    }

    public int getRecurringInvoiceCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM RecurringInvoices")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get recurring invoice count", e);
        }
    }

    public void processRecurringInvoices() throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT i.*, ri.id AS recurringId, ri.frequency, ri.nextDate, ri.endDate " +
                "FROM RecurringInvoices ri " +
                "JOIN Invoices i ON ri.invoiceId = i.id " +
                "WHERE ri.nextDate <= CURDATE() AND (ri.endDate IS NULL OR ri.endDate >= CURDATE())")) {
                ResultSet rs = stmt.executeQuery();
                while (rs.next()) {
                    String invoiceId = rs.getString("id");
                    String newInvoiceId = generateInvoiceId(invoiceId.substring(0, 3));
                    Integer customerId = rs.getObject("customerId") != null ? rs.getInt("customerId") : null;
                    String type = rs.getString("type");
                    String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
                    double totalAmount = rs.getDouble("totalAmount");
                    String currency = rs.getString("currency");
                    String paymentCurrency = rs.getString("paymentCurrency");
                    String paymentInstructions = rs.getString("paymentInstructions");
                    String deliveryStatus = rs.getString("deliveryStatus");
                    String notes = rs.getString("notes");
                    double exchangeRate = rs.getDouble("exchangeRate");
                    List<InvoiceLineItem> lineItems = loadLineItems(invoiceId);
                    int frequency = rs.getInt("frequency");

                    try (PreparedStatement insertStmt = conn.prepareStatement(
                        "INSERT INTO Invoices (id, customerId, type, date, totalAmount, currency, paymentCurrency, paymentInstructions, deliveryStatus, notes, exchangeRate) " +
                        "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                        insertStmt.setString(1, newInvoiceId);
                        insertStmt.setObject(2, customerId, Types.INTEGER);
                        insertStmt.setString(3, type);
                        insertStmt.setString(4, date);
                        insertStmt.setDouble(5, totalAmount);
                        insertStmt.setString(6, currency);
                        insertStmt.setString(7, paymentCurrency);
                        insertStmt.setString(8, paymentInstructions);
                        insertStmt.setString(9, deliveryStatus);
                        insertStmt.setString(10, notes);
                        insertStmt.setDouble(11, exchangeRate);
                        insertStmt.executeUpdate();
                    }

                    for (InvoiceLineItem item : lineItems) {
                        try (PreparedStatement lineStmt = conn.prepareStatement(
                            "INSERT INTO InvoiceLineItems (invoiceId, productId, warehouseId, quantity, unit, unitPrice, totalPrice, unitCost, totalCost, currency) " +
                            "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")) {
                            lineStmt.setString(1, newInvoiceId);
                            lineStmt.setInt(2, item.getProductId());
                            lineStmt.setInt(3, item.getWarehouseId());
                            lineStmt.setInt(4, item.getQuantity());
                            lineStmt.setString(5, item.getUnit());
                            lineStmt.setDouble(6, item.getUnitPrice());
                            lineStmt.setDouble(7, item.getTotalPrice());
                            lineStmt.setDouble(8, item.getUnitCost());
                            lineStmt.setDouble(9, item.getTotalCost());
                            lineStmt.setString(10, item.getCurrency());
                            lineStmt.executeUpdate();
                        }
                    }

                    updateInvoiceTransactions(conn, newInvoiceId, customerId, totalAmount, type, lineItems);

                    try (PreparedStatement updateStmt = conn.prepareStatement(
                        "UPDATE RecurringInvoices SET nextDate = DATE_ADD(nextDate, INTERVAL ? DAY), lastGenerated = CURDATE() WHERE id = ?")) {
                        updateStmt.setInt(1, frequency);
                        updateStmt.setInt(2, rs.getInt("recurringId"));
                        updateStmt.executeUpdate();
                    }
                }
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw new DatabaseException("Failed to process recurring invoices", e);
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to process recurring invoices", e);
        }
    }

    public List<String> getOverduePayments(int pageNumber, int pageSize) throws DatabaseException {
        List<String> overduePayments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT i.id, i.totalAmount, c.name " +
                 "FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0 " +
                 "LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                overduePayments.add("Invoice ID: " + rs.getString("id") + ", Customer: " + rs.getString("name") + ", Amount: " + rs.getDouble("totalAmount") + " USD");
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get overdue payments", e);
        }
        return overduePayments;
    }

    public int getOverduePaymentCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COUNT(*) FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get overdue payment count", e);
        }
    }

    public void markPaymentReceived(String customerName, double amount, String currency, double exchangeRate, String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            int customerId;
            try (PreparedStatement stmt = conn.prepareStatement("SELECT id FROM Customers WHERE name = ?")) {
                stmt.setString(1, customerName);
                ResultSet rs = stmt.executeQuery();
                if (!rs.next()) throw new DatabaseException("Customer not found: " + customerName, null);
                customerId = rs.getInt("id");
            }

            double currentDebitUSD = getCustomerDebit(customerId);
            double paymentInUSD = currency.equals("USD") ? amount : amount / exchangeRate;
            if (paymentInUSD > currentDebitUSD && invoiceId != null) {
                throw new DatabaseException("Payment amount (" + paymentInUSD + " USD) exceeds customer debit (" + currentDebitUSD + " USD)", null);
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Payments (customerId, invoiceId, amount, paymentDate, currency, exchangeRate) VALUES (?, ?, ?, NOW(), ?, ?)")) {
                stmt.setInt(1, customerId);
                stmt.setString(2, invoiceId);
                stmt.setDouble(3, amount);
                stmt.setString(4, currency);
                stmt.setDouble(5, exchangeRate);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, NOW())")) {
                stmt.setInt(1, customerId);
                stmt.setDouble(2, paymentInUSD);
                stmt.setString(3, invoiceId != null ? "Payment for Invoice #" + invoiceId : "General Payment");
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Payments', NOW())")) {
                stmt.setString(1, "Payment from " + customerName + (invoiceId != null ? " for Invoice #" + invoiceId : " (General)") + " in " + currency);
                stmt.setDouble(2, paymentInUSD);
                stmt.executeUpdate();
            }

            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DatabaseException("Rollback failed after marking payment", rollbackEx);
            }
            throw new DatabaseException("Failed to mark payment received for: " + customerName, e);
        }
    }

    public double getCustomerDebit(int customerId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COALESCE(SUM(d.amount), 0) - COALESCE(SUM(c.amount), 0) AS debitCredit " +
                 "FROM Customers cu " +
                 "LEFT JOIN CustomerDebits d ON cu.id = d.customerId " +
                 "LEFT JOIN CustomerCredits c ON cu.id = c.customerId " +
                 "WHERE cu.id = ?")) {
            stmt.setInt(1, customerId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("debitCredit");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get customer debit for ID: " + customerId, e);
        }
    }

    public void addInventoryItem(int productId, int warehouseId, int quantity) throws DatabaseException {
        Product product = productCache.get(productId);
        if (product == null) throw new DatabaseException("Product not found in cache: " + productId, null);
        double cost = product.getCostPrice() * quantity;

        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Inventory (productId, warehouseId, quantity) " +
                "VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE quantity = quantity + ?")) {
                stmt.setInt(1, productId);
                stmt.setInt(2, warehouseId);
                stmt.setInt(3, quantity);
                stmt.setInt(4, quantity);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO InventoryTransactions (productId, warehouseId, quantity, type, date, cost) " +
                "VALUES (?, ?, ?, 'IN', NOW(), ?)")) {
                stmt.setInt(1, productId);
                stmt.setInt(2, warehouseId);
                stmt.setInt(3, quantity);
                stmt.setDouble(4, cost);
                stmt.executeUpdate();
            }

            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO CashTransactions (description, amount, type, category, date) " +
                "VALUES (?, ?, 'OUT', 'Inventory Purchase', NOW())")) {
                stmt.setString(1, "Inventory Purchase for Product #" + productId);
                stmt.setDouble(2, cost);
                stmt.executeUpdate();
            }
            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DatabaseException("Rollback failed after adding inventory item", rollbackEx);
            }
            throw new DatabaseException("Failed to add inventory item for product: " + productId, e);
        }
    }

    public List<InventoryItem> getInventoryItems(int pageNumber, int pageSize) throws DatabaseException {
        List<InventoryItem> inventoryItems = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT productId, warehouseId, quantity FROM Inventory ORDER BY productId, warehouseId LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                inventoryItems.add(new InventoryItem(
                    rs.getInt("productId"),
                    rs.getInt("warehouseId"),
                    rs.getInt("quantity")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get inventory items", e);
        }
        return inventoryItems;
    }

    public int getInventoryCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Inventory")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get inventory count", e);
        }
    }

    public void addAttachment(String invoiceId, String fileName, long fileSize, String uploadDate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO Attachments (invoiceId, fileName, fileSize, uploadDate) VALUES (?, ?, ?, ?)")) {
            stmt.setString(1, invoiceId);
            stmt.setString(2, fileName);
            stmt.setLong(3, fileSize);
            stmt.setString(4, uploadDate);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add attachment to invoice: " + invoiceId, e);
        }
    }

    public List<Attachment> getAttachments(String invoiceId, int pageNumber, int pageSize) throws DatabaseException {
        List<Attachment> attachments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM Attachments WHERE invoiceId = ? ORDER BY uploadDate LIMIT ? OFFSET ?")) {
            stmt.setString(1, invoiceId);
            stmt.setInt(2, pageSize);
            stmt.setInt(3, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                attachments.add(new Attachment(
                    rs.getInt("id"),
                    rs.getString("fileName"),
                    rs.getLong("fileSize"),
                    rs.getString("uploadDate")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get attachments for invoice: " + invoiceId, e);
        }
        return attachments;
    }

    public int getAttachmentCount(String invoiceId) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Attachments WHERE invoiceId = ?")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get attachment count for invoice: " + invoiceId, e);
        }
    }

    public void addAdjustment(String type, String description, double amount, Integer accountFrom, Integer accountTo, String date, String currency, double exchangeRate) throws DatabaseException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try (PreparedStatement stmt = conn.prepareStatement(
                "INSERT INTO Adjustments (type, description, amount, accountFrom, accountTo, date, currency, exchangeRate) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")) {
                stmt.setString(1, type);
                stmt.setString(2, description);
                stmt.setDouble(3, amount);
                stmt.setObject(4, accountFrom, Types.INTEGER);
                stmt.setObject(5, accountTo, Types.INTEGER);
                stmt.setString(6, date);
                stmt.setString(7, currency);
                stmt.setDouble(8, exchangeRate);
                stmt.executeUpdate();
            }

            switch (type) {
                case "BALANCE_TRANSFER":
                    if (accountFrom != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountFrom);
                            stmt.setDouble(2, amount);
                            stmt.setString(3, description);
                            stmt.setString(4, date);
                            stmt.executeUpdate();
                        }
                    }
                    if (accountTo != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerCredits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountTo);
                            stmt.setDouble(2, amount);
                            stmt.setString(3, description);
                            stmt.setString(4, date);
                            stmt.executeUpdate();
                        }
                    }
                    break;
                case "INVENTORY_VALUATION":
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', 'Inventory Adjustment', ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amount);
                        stmt.setString(3, date);
                        stmt.executeUpdate();
                    }
                    break;
                case "DEFERRED_EXPENSE":
                case "TAX_DUE":
                case "OTHER_PAYMENT":
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amount);
                        stmt.setString(3, type.equals("DEFERRED_EXPENSE") ? "Deferred Expenses" : type.equals("TAX_DUE") ? "Taxes" : "Other Payments");
                        stmt.setString(4, date);
                        stmt.executeUpdate();
                    }
                    break;
                case "ACCRUED_REVENUE":
                    if (accountTo != null) {
                        try (PreparedStatement stmt = conn.prepareStatement(
                            "INSERT INTO CustomerDebits (customerId, amount, description, date) VALUES (?, ?, ?, ?)")) {
                            stmt.setInt(1, accountTo);
                            stmt.setDouble(2, amount);
                            stmt.setString(3, description);
                            stmt.setString(4,date);
                            stmt.executeUpdate();
                        }
                    }
                    try (PreparedStatement stmt = conn.prepareStatement(
                        "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'IN', 'Accrued Revenue', ?)")) {
                        stmt.setString(1, description);
                        stmt.setDouble(2, amount);
                        stmt.setString(3, date);
                        stmt.executeUpdate();
                    }
                    break;
            }
            conn.commit();
        } catch (SQLException e) {
            try (Connection conn = dataSource.getConnection()) {
                conn.rollback();
            } catch (SQLException rollbackEx) {
                throw new DatabaseException("Rollback failed after adding adjustment", rollbackEx);
            }
            throw new DatabaseException("Failed to add adjustment: " + description, e);
        }
    }

    public List<Adjustment> getAdjustments(int pageNumber, int pageSize) throws DatabaseException {
        List<Adjustment> adjustments = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM Adjustments ORDER BY date DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                adjustments.add(new Adjustment(
                    rs.getInt("id"),
                    rs.getString("type"),
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getObject("accountFrom", Integer.class),
                    rs.getObject("accountTo", Integer.class),
                    rs.getString("date"),
                    rs.getString("currency"),
                    rs.getDouble("exchangeRate")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get adjustments", e);
        }
        return adjustments;
    }

    public int getAdjustmentCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM Adjustments")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get adjustment count", e);
        }
    }

    public void addExpense(String description, double amount, String currency, String category, String date) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO CashTransactions (description, amount, type, category, date) VALUES (?, ?, 'OUT', ?, ?)")) {
            stmt.setString(1, description);
            stmt.setDouble(2, amount);
            stmt.setString(3, category);
            stmt.setString(4, date);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DatabaseException("Failed to add expense: " + description, e);
        }
    }

    public List<Expense> getExpenses(int pageNumber, int pageSize) throws DatabaseException {
        List<Expense> expenses = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT description, amount, currency, category, date FROM CashTransactions WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns', 'Inventory Adjustment', 'Deferred Expenses', 'Taxes', 'Other Payments') ORDER BY date DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                expenses.add(new Expense(
                    rs.getString("description"),
                    rs.getDouble("amount"),
                    rs.getString("currency"),
                    rs.getString("category"),
                    rs.getString("date")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get expenses", e);
        }
        return expenses;
    }

    public int getExpenseCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT COUNT(*) FROM CashTransactions WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns', 'Inventory Adjustment', 'Deferred Expenses', 'Taxes', 'Other Payments')")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get expense count", e);
        }
    }

    public void setBudget(String category, double amount) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO Budgets (category, amount) VALUES (?, ?) ON DUPLICATE KEY UPDATE amount = ?")) {
            stmt.setString(1, category);
            stmt.setDouble(2, amount);
            stmt.setDouble(3, amount);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DatabaseException("Failed to set budget for category: " + category, e);
        }
    }

    public double getBudgetLimit(String category) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT amount FROM Budgets WHERE category = ?")) {
            stmt.setString(1, category);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("amount");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get budget limit for category: " + category, e);
        }
    }

    public double getTotalExpensesByCategory(String category) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(amount) as total FROM CashTransactions WHERE type = 'OUT' AND category = ?")) {
            stmt.setString(1, category);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get total expenses for category: " + category, e);
        }
    }

    public double getTotalSales() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(totalAmount) as total FROM Invoices WHERE type = 'SALE'")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get total sales", e);
        }
    }

    public double getOverdueAmount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(totalAmount) as total FROM Invoices i " +
                 "JOIN Customers c ON i.customerId = c.id " +
                 "WHERE i.type = 'SALE' AND i.date < CURDATE() AND i.totalAmount > 0")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("total");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get overdue amount", e);
        }
    }

    public double getCashBalance() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as balance FROM CashTransactions")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getDouble("balance");
            return 0.0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get cash balance", e);
        }
    }

    public Map<String, Double> generateCompanyFinancialSummary(String startDate, String endDate) throws DatabaseException {
        Map<String, Double> summary = new HashMap<>();
        try (Connection conn = dataSource.getConnection()) {
            double totalRevenue = 0.0;
            double totalCogs = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(li.totalPrice) as totalRevenue, SUM(li.totalCost) as totalCogs " +
                "FROM Invoices i " +
                "JOIN InvoiceLineItems li ON i.id = li.invoiceId " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    totalRevenue = rs.getDouble("totalRevenue");
                    totalCogs = rs.getDouble("totalCogs");
                }
            }

            double totalExpenses = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalExpenses " +
                "FROM CashTransactions " +
                "WHERE type = 'OUT' AND category NOT IN ('COGS', 'Sales Returns') AND date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalExpenses = rs.getDouble("totalExpenses");
            }
            summary.put("Profit", totalRevenue - totalCogs - totalExpenses);

            double initialCash = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE -amount END) as initialCash " +
                "FROM CashTransactions " +
                "WHERE date < ?")) {
                stmt.setString(1, startDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) initialCash = rs.getDouble("initialCash");
            }

            double periodCashInflows = 0.0;
            double periodCashOutflows = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(CASE WHEN type = 'IN' THEN amount ELSE 0 END) as inflows, " +
                "SUM(CASE WHEN type = 'OUT' THEN amount ELSE 0 END) as outflows " +
                "FROM CashTransactions " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    periodCashInflows = rs.getDouble("inflows");
                    periodCashOutflows = rs.getDouble("outflows");
                }
            }
            summary.put("Cash", initialCash + periodCashInflows - periodCashOutflows);

            double avgInventory = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT AVG(quantity * p.costPrice) as avgInventory " +
                "FROM Inventory i " +
                "JOIN Products p ON i.productId = p.id " +
                "WHERE EXISTS (SELECT 1 FROM InventoryTransactions it WHERE it.productId = i.productId AND it.date BETWEEN ? AND ?)")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) avgInventory = rs.getDouble("avgInventory");
            }
            summary.put("Inventory Turnover", avgInventory > 0 ? totalCogs / avgInventory : 0.0);

            double topCustomerRevenue = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(i.totalAmount) as revenue " +
                "FROM Invoices i " +
                "WHERE i.type = 'SALE' AND i.date BETWEEN ? AND ? " +
                "GROUP BY i.customerId " +
                "ORDER BY revenue DESC LIMIT 1")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) topCustomerRevenue = rs.getDouble("revenue");
            }
            summary.put("Top Customer Revenue", topCustomerRevenue);

            double totalDebits = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalDebits " +
                "FROM CustomerDebits " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalDebits = rs.getDouble("totalDebits");
            }
            summary.put("Debits", totalDebits);

            double totalCredits = 0.0;
            try (PreparedStatement stmt = conn.prepareStatement(
                "SELECT SUM(amount) as totalCredits " +
                "FROM CustomerCredits " +
                "WHERE date BETWEEN ? AND ?")) {
                stmt.setString(1, startDate);
                stmt.setString(2, endDate);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) totalCredits = rs.getDouble("totalCredits");
            }
            summary.put("Credits", totalCredits);
        } catch (SQLException e) {
            throw new DatabaseException("Failed to generate financial summary", e);
        }
        return summary;
    }

    public void logInvoiceChange(String invoiceId, String changeDescription, String changedBy) throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO InvoiceHistory (invoiceId, changeDescription, changedBy, changeDate) VALUES (?, ?, ?, NOW())")) {
            stmt.setString(1, invoiceId);
            stmt.setString(2, changeDescription);
            stmt.setString(3, changedBy);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DatabaseException("Failed to log invoice change for: " + invoiceId, e);
        }
    }

    public List<String> getInvoiceHistory(String invoiceId) throws DatabaseException {
        List<String> history = new ArrayList<>();
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT changeDescription, changedBy, changeDate FROM InvoiceHistory WHERE invoiceId = ? ORDER BY changeDate DESC")) {
            stmt.setString(1, invoiceId);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                history.add(String.format("Date: %s, By: %s, Change: %s",
                    rs.getString("changeDate"), rs.getString("changedBy"), rs.getString("changeDescription")));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get invoice history for: " + invoiceId, e);
        }
        return history;
    }

    public List<AuditEntry> getAuditLogs(int pageNumber, int pageSize) throws DatabaseException {
        List<AuditEntry> logs = new ArrayList<>();
        int offset = (pageNumber - 1) * pageSize;
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT user, tableName, recordId, action, oldValue, newValue, timestamp FROM AuditLog ORDER BY timestamp DESC LIMIT ? OFFSET ?")) {
            stmt.setInt(1, pageSize);
            stmt.setInt(2, offset);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                logs.add(new AuditEntry(
                    rs.getString("timestamp"),
                    rs.getString("user"),
                    rs.getString("tableName"),
                    rs.getString("recordId"),
                    rs.getString("action"),
                    rs.getString("oldValue"),
                    rs.getString("newValue")
                ));
            }
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get audit logs", e);
        }
        return logs;
    }

    public int getAuditLogCount() throws DatabaseException {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement("SELECT COUNT(*) FROM AuditLog")) {
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            return 0;
        } catch (SQLException e) {
            throw new DatabaseException("Failed to get audit log count", e);
        }
    }

    public void close() {
        if (dataSource != null && !dataSource.isClosed()) dataSource.close();
    }

    private <T> List<List<T>> partition(List<T> list, int size) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += size) {
            partitions.add(list.subList(i, Math.min(i + size, list.size())));
        }
        return partitions;
    }

    static class Product {
        private final String name;
        private final double sellingPrice;
        private final double costPrice;
        private final String unit;

        Product(String name, double sellingPrice, double costPrice, String unit) {
            this.name = name;
            this.sellingPrice = sellingPrice;
            this.costPrice = costPrice;
            this.unit = unit;
        }

        public String getName() { return name; }
        public double getSellingPrice() { return sellingPrice; }
        public double getCostPrice() { return costPrice; }
        public String getUnit() { return unit; }
    }
}

/**
 * Service class for audit logging.
 */
class AuditService {
    private static final Logger LOGGER = Logger.getLogger(AuditService.class.getName());
    private final DatabaseService dbService;

    public AuditService(DatabaseService dbService) {
        this.dbService = dbService;
    }

    public void logAction(String user, String tableName, String recordId, String action, String oldValue, String newValue) {
        try (Connection conn = dbService.dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO AuditLog (user, tableName, recordId, action, oldValue, newValue, timestamp) VALUES (?, ?, ?, ?, ?, ?, NOW())")) {
            stmt.setString(1, user);
            stmt.setString(2, tableName);
            stmt.setString(3, recordId);
            stmt.setString(4, action);
            stmt.setString(5, oldValue);
            stmt.setString(6, newValue);
            stmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.severe("Error logging action: " + e.getMessage());
        }
    }
}

/**
 * Represents a line item in an invoice with a warehouse and currency.
 */
class InvoiceLineItem {
    private final int id;
    private final int productId;
    private final int warehouseId;
    private final int quantity;
    private final String unit;
    private final double unitPrice;
    private final double totalPrice;
    private final double unitCost;
    private final double totalCost;
    private final String currency;

    public InvoiceLineItem(int id, int productId, int warehouseId, int quantity, String unit, double unitPrice, double totalPrice, double unitCost, double totalCost, String currency) {
        this.id = id;
        this.productId = productId;
        this.warehouseId = warehouseId;
        this.quantity = quantity;
        this.unit = unit;
        this.unitPrice = unitPrice;
        this.totalPrice = totalPrice;
        this.unitCost = unitCost;
        this.totalCost = totalCost;
        this.currency = currency;
    }

    public int getId() { return id; }
    public int getProductId() { return productId; }
    public int getWarehouseId() { return warehouseId; }
    public int getQuantity() { return quantity; }
    public String getUnit() { return unit; }
    public double getUnitPrice() { return unitPrice; }
    public double getTotalPrice() { return totalPrice; }
    public double getUnitCost() { return unitCost; }
    public double getTotalCost() { return totalCost; }
    public String getCurrency() { return currency; }
    public String getDescription() { return "Product ID: " + productId; }
}

/**
 * Represents detailed information about an invoice.
 */
class InvoiceDetails {
    private final String invoiceId;
    private final String invoiceType;
    private final String customerName;
    private final String warehouseName;
    private final String date;
    private final double itemsTotal;
    private final double totalDebit;
    private final double lastDebit;
    private final String currency;
    private final String deliveryStatus;
    private final String paymentTerms;
    private final String notes;
    private final List<InvoiceLineItem> lineItems;
    private final double usdTotal;
    private final double localTotal;

    public InvoiceDetails(String invoiceId, String invoiceType, String customerName, String warehouseName, String date,
                          double itemsTotal, double totalDebit, double lastDebit, String currency,
                          String deliveryStatus, String paymentTerms, String notes, List<InvoiceLineItem> lineItems,
                          double usdTotal, double localTotal) {
        this.invoiceId = invoiceId;
        this.invoiceType = invoiceType;
        this.customerName = customerName;
        this.warehouseName = warehouseName;
        this.date = date;
        this.itemsTotal = itemsTotal;
        this.totalDebit = totalDebit;
        this.lastDebit = lastDebit;
        this.currency = currency;
        this.deliveryStatus = deliveryStatus;
        this.paymentTerms = paymentTerms;
        this.notes = notes;
        this.lineItems = lineItems;
        this.usdTotal = usdTotal;
        this.localTotal = localTotal;
    }

    public String getInvoiceId() { return invoiceId; }
    public String getInvoiceType() { return invoiceType; }
    public String getCustomerName() { return customerName; }
    public String getWarehouseName() { return warehouseName; }
    public String getDate() { return date; }
    public double getItemsTotal() { return itemsTotal; }
    public double getTotalDebit() { return totalDebit; }
    public double getLastDebit() { return lastDebit; }
    public double getTotalAmount() { return itemsTotal; }
    public String getCurrency() { return currency; }
    public String getDeliveryStatus() { return deliveryStatus; }
    public String getPaymentTerms() { return paymentTerms; }
    public String getNotes() { return notes; }
    public List<InvoiceLineItem> getLineItems() { return lineItems; }
    public double getUsdTotal() { return usdTotal; }
    public double getLocalTotal() { return localTotal; }
}

/**
 * Represents an inventory item.
 */
class InventoryItem {
    private final int productId;
    private final int warehouseId;
    private final int quantity;

    public InventoryItem(int productId, int warehouseId, int quantity) {
        this.productId = productId;
        this.warehouseId = warehouseId;
        this.quantity = quantity;
    }

    public int getProductId() { return productId; }
    public int getWarehouseId() { return warehouseId; }
    public int getQuantity() { return quantity; }
}

/**
 * Represents an attachment to an invoice.
 */
class Attachment {
    private final int id;
    private final String fileName;
    private final long fileSize;
    private final String uploadDate;

    public Attachment(int id, String fileName, long fileSize, String uploadDate) {
        this.id = id;
        this.fileName = fileName;
        this.fileSize = fileSize;
        this.uploadDate = uploadDate;
    }

    public int getId() { return id; }
    public String getFileName() { return fileName; }
    public long getFileSize() { return fileSize; }
    public String getUploadDate() { return uploadDate; }
}

/**
 * Represents an adjustment for settlement purposes.
 */
class Adjustment {
    private final int id;
    private final String type;
    private final String description;
    private final double amount;
    private final Integer accountFrom;
    private final Integer accountTo;
    private final String date;
    private final String currency;
    private final double exchangeRate;

    public Adjustment(int id, String type, String description, double amount, Integer accountFrom, Integer accountTo, String date, String currency, double exchangeRate) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.amount = amount;
        this.accountFrom = accountFrom;
        this.accountTo = accountTo;
        this.date = date;
        this.currency = currency;
        this.exchangeRate = exchangeRate;
    }

    public int getId() { return id; }
    public String getType() { return type; }
    public String getDescription() { return description; }
    public double getAmount() { return amount; }
    public Integer getAccountFrom() { return accountFrom; }
    public Integer getAccountTo() { return accountTo; }
    public String getDate() { return date; }
    public String getCurrency() { return currency; }
    public double getExchangeRate() { return exchangeRate; }
}

/**
 * Represents a recurring invoice.
 */
class RecurringInvoice {
    private final int id;
    private final String invoiceId;
    private final int frequency;
    private final String nextDate;
    private final String endDate;
    private final String lastGenerated;

    public RecurringInvoice(int id, String invoiceId, int frequency, String nextDate, String endDate, String lastGenerated) {
        this.id = id;
        this.invoiceId = invoiceId;
        this.frequency = frequency;
        this.nextDate = nextDate;
        this.endDate = endDate;
        this.lastGenerated = lastGenerated;
    }

    public int getId() { return id; }
    public String getInvoiceId() { return invoiceId; }
    public int getFrequency() { return frequency; }
    public String getNextDate() { return nextDate; }
    public String getEndDate() { return endDate; }
    public String getLastGenerated() { return lastGenerated; }
}

/**
 * Represents a contact (customer or supplier).
 */
class Contact {
    private final int id;
    private final String name;
    private final String contact;
    private final String email;
    private final String address;

    public Contact(int id, String name, String contact, String email, String address) {
        this.id = id;
        this.name = name;
        this.contact = contact;
        this.email = email;
        this.address = address;
    }

    public int getId() { return id; }
    public String getName() { return name; }
    public String getContact() { return contact; }
    public String getEmail() { return email; }
    public String getAddress() { return address; }

    @Override
    public String toString() {
        return "Contact{id=" + id + ", name='" + name + "', contact='" + contact + "', email='" + email + "', address='" + address + "'}";
    }
}

/**
 * Represents an expense record.
 */
class Expense {
    private final String description;
    private final double amount;
    private final String currency;
    private final String category;
    private final String date;

    public Expense(String description, double amount, String currency, String category, String date) {
        this.description = description;
        this.amount = amount;
        this.currency = currency;
        this.category = category;
        this.date = date;
    }

    public String getDescription() { return description; }
    public double getAmount() { return amount; }
    public String getCurrency() { return currency; }
    public String getCategory() { return category; }
    public String getDate() { return date; }
}

/**
 * Represents an audit log entry.
 */
class AuditEntry {
    private final String timestamp;
    private final String user;
    private final String tableName;
    private final String recordId;
    private final String action;
    private final String oldValue;
    private final String newValue;

    public AuditEntry(String timestamp, String user, String tableName, String recordId, String action, String oldValue, String newValue) {
        this.timestamp = timestamp;
        this.user = user;
        this.tableName = tableName;
        this.recordId = recordId;
        this.action = action;
        this.oldValue = oldValue;
        this.newValue = newValue;
    }

    public String getTimestamp() { return timestamp; }
    public String getUser() { return user; }
    public String getTableName() { return tableName; }
    public String getRecordId() { return recordId; }
    public String getAction() { return action; }
    public String getOldValue() { return oldValue; }
    public String getNewValue() { return newValue; }
}

/**
 * Formatter for date fields in the UI.
 */
class DateLabelFormatter extends JFormattedTextField.AbstractFormatter {
    private static final String DATE_PATTERN = "yyyy-MM-dd";
    private final SimpleDateFormat dateFormatter = new SimpleDateFormat(DATE_PATTERN);

    @Override
    public Object stringToValue(String text) throws ParseException {
        return dateFormatter.parseObject(text);
    }

    @Override
    public String valueToString(Object value) throws ParseException {
        if (value != null) {
            if (value instanceof Date) return dateFormatter.format((Date) value);
            else if (value instanceof GregorianCalendar) return dateFormatter.format(((GregorianCalendar) value).getTime());
            else throw new IllegalArgumentException("Unsupported date type: " + value.getClass().getName());
        }
        return "";
    }
}